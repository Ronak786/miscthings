前512=》 boot.img
    需要集合bios部分，分区表部分等功能，可用地方少，加载core img的第一个扇区，
        记录咋内部的，安装的时候 , 到0x8000（自己在0x7c00）
    加载的coreimg的第一个扇区叫做diskboot img， 这个，加载其他扇区，
        具体在安装的时候记录，记载多个表示连续扇区块的blocklist中
        然后加载后续img，首先是未压缩的img，用来解压后面的压缩的kernelimg，
        然后跳转执行kernelimg，这个则把之前一起加载进来的模块进行重定位，
        然后就可以识别磁盘，分区和文件系统了，然后就加载文件系统里的模块
        或者boot分区了

    安装的时候， grub-mkimage => grup-setup (整个是 grub-install)
        1 制作完整的coreimg
        首先是读取kernel img，然后是把grub probe获取的需要的模块
        放在后面，然后压缩，整个前面放上解压代码，然后前面加上diskboot那个
        mbr中载入的部分，最后整个写入硬盘上放coreimg的62个扇区中即可
        2 写入coreimg 和bootimg
            bootimg写入mbr， 其中修改diskbootimg的扇区位置，
                diskbootimg写入某个扇区，里面用blocklist写入可以不连续的
                coreimg其他部分（解压工具部分和压缩的kernel， mod部分）

            加压缩使用1M处的地方用于存放解压的kernel和mod，然后跳转过去，
            kernel把自己移回0x9000位置，mod先不动，然后执行C的grubmain，
            里面负责mod模块的重定位和放回到1M以下（用了保护模式访问1M
            上部分， 内核可能会用，所以要移动回来）


加载内核：
    x86：只要载入32位的部分就行了，实模式的没用了
        linux命令会导致读取实模式的0x1f1处的一个setup的头部，
            在arch/x86/boot/header.S中，这里面有实模式的长度和其他信息，
            然后生成一个kernek_param结构体，把setupheader读入，
            还要把另一部分作为zero page，也就是调用bios功能获取
            系统如显示信息，全部填入后，然后放到esi寄存器指定的位置，
            然后设置gdt，es ip，这个都是根据内核boot协议的，在
            documentation/x86/boot里面有，最后长跳转0xea进入内核

            initramfs的信息也是记录在param结构体里面的,放在内核载入
            的内存的后面，有一个上界位置的

    
    解压：
        压缩的长度位置等信息都在未压缩部分的头部，具体解压缩需要首先
        把整个img包括自己移动到稍微靠后的地方，由offset信息提供，然后
        开始往前解压，写指针在读指针的位置之前，

        如果kernel可重定位，grub载入的位置可作为启动位置，不然要放到指定位置，
            并且需要对其指定值，config可以指定,内核符号重定位表放在最后，
            如果要重定位，需要根据这张表把里面的符号的位置重定位,
            注意虚实地址的转换以及符号表本身定位偏移的问题

    分页 分段：
        开始保护模式，使用分段，现代内核一进入就是保护模式了，不过是平坦模式，
        没有分页，所以需要输入物理地址，但是编译的时候都是虚拟地址，所以一开始的
        第一个lgdt设置使用的标号需要减去3G的偏移， 后面开页后重新load gdtr则使用
        虚拟地址了，所以不需要了
