前512=》 boot.img
    需要集合bios部分，分区表部分等功能，可用地方少，加载core img的第一个扇区，
        记录咋内部的，安装的时候 , 到0x8000（自己在0x7c00）
    加载的coreimg的第一个扇区叫做diskboot img， 这个，加载其他扇区，
        具体在安装的时候记录，记载多个表示连续扇区块的blocklist中
        然后加载后续img，首先是未压缩的img，用来解压后面的压缩的kernelimg，
        然后跳转执行kernelimg，这个则把之前一起加载进来的模块进行重定位，
        然后就可以识别磁盘，分区和文件系统了，然后就加载文件系统里的模块
        或者boot分区了

    安装的时候， grub-mkimage => grup-setup (整个是 grub-install)
        1 制作完整的coreimg
        首先是读取kernel img，然后是把grub probe获取的需要的模块
        放在后面，然后压缩，整个前面放上解压代码，然后前面加上diskboot那个
        mbr中载入的部分，最后整个写入硬盘上放coreimg的62个扇区中即可
        2 写入coreimg 和bootimg
            bootimg写入mbr， 其中修改diskbootimg的扇区位置，
                diskbootimg写入某个扇区，里面用blocklist写入可以不连续的
                coreimg其他部分（解压工具部分和压缩的kernel， mod部分）

            加压缩使用1M处的地方用于存放解压的kernel和mod，然后跳转过去，
            kernel把自己移回0x9000位置，mod先不动，然后执行C的grubmain，
            里面负责mod模块的重定位和放回到1M以下（用了保护模式访问1M
            上部分， 内核可能会用，所以要移动回来）


加载内核：
    x86：只要载入32位的部分就行了，实模式的没用了
        linux命令会导致读取实模式的0x1f1处的一个setup的头部，
            在arch/x86/boot/header.S中，这里面有实模式的长度和其他信息，
            然后生成一个kernek_param结构体，把setupheader读入，
            还要把另一部分作为zero page，也就是调用bios功能获取
            系统如显示信息，全部填入后，然后放到esi寄存器指定的位置，
            然后设置gdt，es ip，这个都是根据内核boot协议的，在
            documentation/x86/boot里面有，最后长跳转0xea进入内核

            initramfs的信息也是记录在param结构体里面的,放在内核载入
            的内存的后面，有一个上界位置的

    
