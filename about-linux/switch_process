对于刚开始fork出来的进程，没有事先的从用户切进来的过程，所以没有压栈的用户现场那些ss sp cs ip eflags， 所以首先必须在task struct中的thread info中保存内核的sp0 指针位置，内核ss固定是kernel ds，不变， 然后在load elf中自己手写以分现场，用户态的ip地址就是elf的起始地址等等，而内核态的起始地址则是一个kernek init函数，然后是retfromfork返回， 这些在切换前必须放到TSS中去，linux没有完全使用这个，但是intel必须使用，所以这个里面是每次switch的时候更改了tss需要载入的内核ip sp位置，这样就相当于每次切换了，而现场保存，现场回复则是使用中断寄存器


page fault:
    刚创建的进程页是空的，如果访问地址，首先检测是否在建立的vma范围内，或者是否
    是需要expand的stack的页，如果是，就可以do page fault，具体是分配pgd pmd 
    直到pte的分配，然后计算具体载入页的位置，具体看载入时候的load段相对于文件
    的位移，然后是你的虚拟地址相对于段首虚拟地址的位移，分别4k页对齐后相加，就是需要的页的位置，然后调用do fault， 会找到对应的文件系统的fault函数，然后载入对应的页就行了


变量重定位：
    首先使用的exe或so中，具体使用的地方是根据代码和data中的got表偏移固定的特征，同时readelf -r找到符号在本文件的偏移（global_offset_table) 然后这些都用相对偏移直接在代码里固定，这样就不用更改共享库的代码段了（数据段还是每个exe一份的）。
    而修改got表（got got。plt 后者是函数符号，前者变量符号），则需要首先根据readelf -r找到需要修订的符号在got中的位置，（注意真正的位置是动态链接之后记录的load address加上这里的偏移构成的）， 然后再找产生符号的so中的load之后符号的位置地址，然后写入这里就行了

函数重定位： readelf -d -j .plt zxxx 看具体的段代码
    函数较多，所以不会在加载的时候直接重定位在got表中，而是使用一个plt表做中间重定位符号信息保存，然后每次引用的时候，跳转到plt段中，然后利用压入.rel.plt中对应符号的位置，然后调用。got段中的解析函数，把got表中对应的位置进行修改,这里利用了跳转技巧取消了第一次跳转的判断，以后每次过来，直接plt表跳转进入got表对应的位置就可以运行到函数了， 这就是pic的好处，如果加载时就重定位，不用got，那么还是不能共享库，代码段会被修改的  

注意：
    动态库中的重定位，got表需要使用相对偏移某个重定位过的got地址含有寄存器，不然找不到的，而exe的重定位，got表编译时确定位置，直接写地址的

可执行文件：
    使用库的外部变量的方式，是编译链接的时候分配一个同名变量，然后载入动态库后，所有这个变量的引用到放着这个变量而不是库内变量上，直接修改， 如果始顶-fpic，则会使用got表来处理

只读段：
    gcc -z,relro   gcc -dumpspecs 显示所有
    这样可以把got段， （非got.plt段）在加载重定位后设置为只读，减少溢出攻击的可能


