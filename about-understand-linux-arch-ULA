namespace: 
	in a namespace , other things outside can not interfer with it, used by virtual machine as a container
	
memory space:
	virtual memory in 64bit will not all be used , to just 40~50bit is enough , and save cpu overload ,
		so have holes in memory pagetable

into kernel method:
	user space syscall
	interrupt from hardware
	kernel threads being run by schedule? ps will show like [XXX/1] means XXX threads run on cpu 1

page and tlb :
	page have herichy , PGD PMD PTE offset , tlb will be flushed every time page table changed , cpu do it or kernel 
		do it ----arch diffs
	
	kernel will always assume  four level page table , sometimes ignore some level , but it is the kernel portion related
		to arch do that , the general part assume four

memory mapping:
	kernel maintain the mapping , others can just access memory , the change will be auto sent to device or file

memory alloca:
	brother system : 
		kernel have a lager contigous chunk of memory, when needed a small one , break into half ,
			if just between half and double half , alloc to him. if not ,continue to break to half,
			then when recycle , if address is contigous , merge to double.(but if frenquently allocated,
				can make scattered )
	slab : 
		this is defined above the brother system , can cache a chunk of memory to allocate small memories
			for structures and so on,  using for example: kmalloc kfree 
	page fault and recycle:
		swap be used to store tmp not used pages , recycle is when memory needed , flush data and recycle
			pages , just mark as page fault on the virtual page(physical page recycled)


system call :
	user to kernel , defined by posix some

net:
	socket is a proxy between user space and kernel .

buffer:
	page cache(cache always in pages .so page cache(
	buffer cache now is little

list:
	list_entry(ptr, type , member ) to get the struct type addr which contains the struct list member pointed by ptr
	list_for_each(tmpvar, &list_head)  will in a for loop return every host struct

kobject:  export to sysfs to manage objects in system(mostly devices models)
	used to represent device models . each object is contained inside the managed object ,
		kset:and some object can become a set , the kset pointer point to the root kset of them
		ktype : a set's common interfaces
		kreference: the object's reference count
		list : all object included in a set
		uevent_ops : funcs about uevent
		

kernel data types:
	1 , typedef __u8 __s8 ...
	2 , cpu_to_le64  le64_to_cpu
	3 , per cpu type , get_cpu(name,cpu)
	4 , user space pointer: use __user identifier

now procceed forward!!



schedule process:
	determine time the process can wrong and how to context switch

processes type :
	hard real time :  not exist in kernel
	soft real time : will suffice as soon as possible
	nornal : scheduled by cfs ...

schedule policy:
	a timeslice , preempted , means when time over , scheduled out 
	O(1) ,CFS the latter will try to give every process a fair time(or even every schedule entity)

process state: <depends on the preempt option on the kernel config>
		running ,waiting(can run but have no cpu) , sleeping , terminate , zombie(terminated but not reaped by father)
		schedule will happen only from leave interrupt or from into userspace , 
		kernel threads also can be preempt 
		interrupt can always preempt others
	
		in task struct ->signal struct -> we have limites (getrlimit setrlimit )used to manipulate
			process's system resource usage	
			also in /proc/self/limits

fork exec clone
	fork then exec , the clone can do like fork but have a finer grained operation

namespace
	can use unshare() to implement , kernel must implement too
uts namespace:
	about the arch and kernel names in diff view , allocate a new structure

pid namespace:
	used for a process to isolate from parent , have a unique overview of the system global pid resources.
	new pid namespace will have new pid 0--init process(but is a normal process in the parent's process view)

INFO:
	in a pid namespace , one task struct(one process) will have many ids in many levels of namespace,
		so it use a struct pid_link(a struct pid) to represent all these(with level and name space as param)-relative
		to one process in diff namespaces(only when in threads , one thread exec and replace all threads in 
			process , then two process(thread) may be have one struct pid
	but one struct pid also will contain lots of taskstructs,when have the same pgid sid , thread id

	1) now , if you have task struct , id type , name space , you can get upid through pid_link,then struct pid ,
		then use level to get the upid
	2)from upid to task_struct:
		every upid is scattered into a hashlist(the var in struct upid) , use namespace and upid to 
			find that struct upid in the hashlist , then find struct pid , then find task_struct(
				usually have only one process in the tasks[TYPEPID]
		in the find_task_by_pid_ns() , provide namespace and upid , it will search the global
			pid_hash[] array(in which is an array of scatter lists,use that hash number to choose one
			list then traverse) to get the struct upid

struct pid:
	we use struct pid to manage all kinds of ids ,pid pgid ptid  sid , because these ids just make 
		some processes to get their place at leader_group->pids[types] (hash list)
	use attach_pid to attach the ip of type from the struct task to the struct pid

	everytime a new process created in the current namespace , all local pids will be allocated by
		alloc_pidmap through alloc_pid to allocate to sevaral namespace


about task struct:
	the group leader is the leader thread of the thread group ,getpid() will return this process's pid
		so the tgid is that pid
