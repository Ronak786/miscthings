use C language
command 
    object encoding profile 会或者当前使用的类型信息

store string(including key and value):
    sds.h/structure sdshdr,  
        use free, len to mark how many in buff used and can be used
        buf is a buf[], so rellocate just reallocate the whole structure, not buf
        use this can make string together with structure, not another buff with a pointer
        二进制安全，因为字符串尾部用length而不是空字符判断，所以可以存储二进制数据
            但是字符串存储一定会存储一个末尾\0,这样可以重用一些函数
    sdcat: 
        append string, and double length to extend free len ,decrease remaining memory alloca
    sdtrim:
        just add to free and not free accually

link list:
    adlist.h/listNode 节点， list 对象结构 
    使用一系列的双链表操作来实现的链表操作

dict:
    redis本身就是dict实现的
    有两个hash表，第二个永远用来rehash，
        当不在bgsave的时候，如果负载因子（总数除以hashslot数）》1,开始rehash，总是取》=当前size*2的最小2的幂级数，
        当正在bgsave，》5,开始
        当《0.1,开始缩减，缩到>=当前size的最小2的幂级数
    rehash:
        渐进，这个不是一次性完成的，有一个rehashidx，这个》=0表示正在进行中，从0开始，每次执行增删添改查操作的时候，
        会在两个表里面进行，但是新增只会在新表里，同时把旧表的rehashidx下的所有rehash到新的里面去，rehashidx增1,
        这样逐渐到新的里面去,
        好处是不会一下子增加负荷

        具体的rehash操作以及新增第一个hash时候的操作都放在dictAdd里面
            这里面具体会首先如果rehash进行中，做掉一部分，然后
            插入前判断是否需要扩容，然后查找是否已经存在，最后返回是否该插入

        其他删查操作也会去判断是否要做一个rehash的

skip list: zset:
   这个条表有一个额外的跨度值，代表了同层下一个值到当前值之间经历的排名跨度，有了
    这个可以快速计算排名，这个在insert的过程中为每层的插入值前一个的rank都计算好了，
    插入的过程就是相关的每层都插入就行了，当然要事先找到每层插入之前的值，放到一个array里面去

    其他的如获取排位等操作（获取分数利用另一个hash表）都是通过从最高级别的链表开始不断往下
        积累排位相加来找的

intset:
    当集合内元素不多且都为整数，用这个
    内部使用一个类型编码表示整数的比特位数，然后数量，然后是内容，就是数组
    增加，减少元素都可以使用不断的类型转换以及memmove来完成，因为移动一个就是所有元素移动一次即可
