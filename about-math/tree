树： 不含回路的连通路
是树 则任意两个顶点间有且只有一条通路

有向图的树：
	从根开始到任意顶点的有向图叫根树o
	树的父母唯一，不然有回路
	树叶是无子女的顶点
	内点是有子女的顶点

m元树：
	每个顶点有至多m个子女， 每个内点有m个子女则为正则m元树
	特例： 二叉树
	左子树， 右子树 是当前顶点的左右子树的称呼

n个顶点的树有n-1条边

对于正则树（也就是必须有m个子女）
n = mi + 1 (n 点总数， m 元， i内点数）
n = l + i   所以任意直到两个，加上m，就可以求出第三个了

顶点的层数：
	顶点到根的路径的长度，根层为0
树的高度：
	顶点的最大层数
平衡树：
	树叶的层数在h和h-1上的树

树的高度h >= log(m)^l l是树叶数目， 向上取整
	如果是正则平衡的，那么高度就是取等号，
一个高度为h的树至多有 m^h个叶子, 所以二叉树在最坏情形下的
	搜索长度至少是这个log数,如果是平衡的话， 高度就是这个数

决策树：
	利用一次决策的结果来决定下一次决策的树的分支
	决策结果数就是m元，最终结果就是树叶，利用上面的
	定理就是log的结果得出最坏情形的比较次数最好值，

	所以基于两两比较的排序算法最坏情形至少是nlogn级别的
	二叉比较的排序算法平均比较次数也是nlogn

前缀码：
	通过前缀可以唯一判定的编码形式，可以通过左子树只有一位，
	右子树不断衍生的方式产生这种编码给不同的数

赫夫曼编码：
	 根据出现频率，不断组合左右子树，通过权来控制放左还是右，产生
		最右前缀码

博弈树：(博弈论可以看看) (layer start from 0)
	列出可能，从树叶开始往上赋值，父母的值是子女中： 偶数层选子女最大，奇数层选最小
			如果双方遵循最大最小策略，那么可以确定谁赢（第一个人总到最大子女，第二个到最小）

	博弈从结果往上，每一步，都由双方找到最利于自己的那个值，反过来，从这个值开始往下，
		是对自己最有利的，最有可能自己胜利的值，一直往上，最终就能找到必胜的值了

	所以博弈树从不同的顶点出发，代表开始的不同情况，就可以决定最终结束的不同情况了

遍历：
	先序： 先本身，再左， 再右
	中序： 先左，再自己，再剩下的所有右
	后续： 先左右，后自己

	一个表达式树，用中序遍历可以得到原式子，
		前序遍历得到波兰记法，无括号，需要从后往前求值
		后序遍历得到逆波兰记法，无括号，从前往后求值
		(但是如何通过计算机的方法从普通表达式构成出一个表达式树？？）


生成树：
	包含每个顶点的连通图的子图，简单图必定存在,
	连通与生成树是充要条件

深度优先： 可以用来产生生成树（就是不含回路的连通路）
	又叫回溯，先一条到底，然后回一位，选择其他分支，继续到底，直到返回最初，就遍历完成
	首先加入v1， 对于与v1相邻并且不在集合中的每一个，加入，然后对它进行同样的操作，
		深度完成一层后就返回一层，继续(每层的每一个都要测试是否回属于集合，因为集合
		的元素数目在增加）

宽度优先：
	把未处理的顶点加入队列，然后每次取出一个，
		加入它所连接的元素到集合,并加入到队列（不在集合中的）

回溯 可以用来做遍历，当到达某一部行不通，就回溯一部，选另一个分支。
	可以用来创造网络爬虫，来探索不同的网络连接

最小生成树：
	最小权值总和的生成树：
	选择最小的边，然后每一步都选择与当前集合内点相连的边中连接不在集合内点
	的边中最小的一个，边数n-1后完成

	第二种算法：
		相继添加不与已添加产生回路的最小的边

	在稀疏图中，第二种更好，需要测试的边少
	在普通图中，都差不多，点的数量比较少
