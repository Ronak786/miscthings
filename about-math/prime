b^n mod m , use (a1a2a3a4..)2 to represent n , 
	then use a mod m == (a mod m ) mod m ,then ab mod m == (amodm * bmod m) mod m
	to multi them together and calculate rest every time

gcd(a , b) always == sa + tb, use ojilide's method and reverse it can be this

每个数可以表示为唯一的一组素数的乘积
gcd(a,b) =1 && a | bc  ==> a | c
gcd(a , b) always == sa + tb, use ojilide's method and reverse it can be this

ac==bc mod m && gcd(c,m) =1, so a==b mod m
模逆， a and ~a mod m, is gcd (a,m) =1 , then ~a is absultedly exist
	sa+tm = 1, tm == 0 mod m , so sa == 1 mod m, we can use 欧几里得方法得到
	上面的等式，然后求出s就是逆
	a~a==1  so a~ax == x, so  if ax==b, a~ax==b~a==x !!

剩余定理
x==a1 mod m1
x==a2 mod m2
....   if gcd(m1,m2)  gcd m2,m3 ==1 .。。
x = a1M1y1 + a2M2y2...... 就是解
其中M1是初当前下表的m外的其他乘积，y1是逆，所以M1y1同余1，所以x==a1 一次类推
根据定理，m1m2m3m4...乘积范围内的所有数，都可以唯一的表示为模m1 m2 m3..之后的一个
n元组（因为只要其中有一个不同，就会产生不同的解映射到不同的整数！！）
这个是用来在不能表示大数的计算机上计算大数的方法

如果a==b mod m1 m2 m3 m4 两两互素，　那么　　a==b mod (m1m2m3m4m5m6)　，　可以从因数只能属于一个m来推导

rsa:
选取素数p q, 乘积n,选取与 (p-1)(q-1)互素的指数ｅ，M^e(modn ) = C, then  de == 1(mod (p-1)(q-1)),
	带入等式替换，so C^d ==M mod(p) (使用费马小定理 x^(a-1) == 1 mod(a) if a is prime),
		C^d == M mod q, so c^d == M mod(pq)(have 证明过了）, 就可以解密了，
		所以加密密钥就是e, n(公开), 解密密钥就是d(要保密(p-1)(q-1), p,q)


抽屉原理：
	put n into k box, at least one box has  uppercase n/k members

P(n,m) pick m from n
C(n,m) pick m from n and no sequence
把无标记的n个球放入有标记的k个盒子：
	相当于用k-1条线切分n个球，所以就是k-1+n中选n个当作球
	所以是C(n+k-1,n)
把有标记的n个球放入有标记的k个盒子：
	相当与n个球排序后，分几组选择，没有中在去掉排序，就是n! / (k1!k2!k3!)
	k1：第一个盒子放几个球

概率：
	p(e|f) = p(e&&f) / p(e)
	贝叶斯 p(e|f) = p(f|e) * p(e) / (p(f|e)*p(e) + p(f|~e)*p(~e))
	可以使用概率来计算组合的概率，如果概率小于1，说明存在不是这种形式的组合
