注意匹配命令周围加引号，不然有shell干扰会报不知所谓的错误

sed 's/old/new/' < orig >newfile 可以不用标准输入，直接作为参数, 引号不是必须的，但是这样
        不容易有shell干扰！！
        默认改变每行第一个
        / 表示分隔，其实可以是任何符号的，跟在s后面自动就识别为分隔符了
        & 用在替换部分表示前面的匹配部分  echo "abc 123" | sed 's/[0-9][0-9]*/(&)/  return abc (123)
            需要两遍0-9因为不然会匹配开头的什么都没有
        -E/-r 这样可以使用 + ? 
        () 这个在匹配部分是正则的符号，所以如果用于正则表达式就不要跳脱，正常的要跳，在替换部分是正常符号
            跳不跳结果都一样
            在替换部分\0是整个匹配，\1是第一个括号 最多九个
            \1 \2 这些也可以放在匹配的那个部分，也就是前面，这个可以用来匹配重复项！！！！
            sed 's/([a-z]+) \1/\1/'

            更正：
                不使用-E时：
                   () 这个属于匹配字符的一部，\( \)这个用于匹配组,可以后面用\1指代的
                使用-E：
                   () 这个成了匹配组 ,\( \)就是匹配的一部分 

                不管怎样 \0都可以用 ,\( \)就是匹配的一部分, &会匹配被匹配的整个部分，有正则就不要用了，会混的

        非递归：
            sed不会递归

        s/xx/xx/g
        s/xx/xx/2g
            g表示每个匹配都替换，默认第一个
            2g表示从第二个匹配开始部替换，地一个不动 ,数字可以是1-512
            


    sed '/xx/p' 这个会显示所有的匹配
        -n  都不打印
            这个和p组合，只有经过sed修改的行才会被打印
        这个p可以放在最后一个分隔符后面，s的匹配之后也可以的

    sed 's/xx/xx/w file' < xxxx
        写入结果到file里面

    sed 's/x/x/I p'
        这里I表示不区分大小写匹配，空格后的p表示p作用整个前面的结果

sed -e 'xxx' -e 'xx':
    接连执行多个sed,每个是前一个的后果

sed xxx  f1 f2 f3  可以多个文件

脚本
    sed -f sedfile < oldinput
        只要放入sed语句就行了

    直接sed脚本：
        #!/bin/sed -nf 这里的n可以屏蔽
        xxx
        xxx
        xxx
        然后 xxx.sed  <old > new

    sh执行：
        如果是把整个语句都放到文件里面当作sh脚本，要使用
        #!/bin/sh
        sed '
        xxx
        xxx
        xxx' < old > new

ｃｏｍｍｅｎｔ：
    #开头的

传参数：
    只要用引号跳脱掉原来的部分，把shell参数加引号正常传入即可 sed -n 's/'"$1"'/he/'

combine with here document:
    sed 'xxxxx' <<eof
    sldkjfldsf
    eof
    
匹配：
    sed  '/ / p' 没有p的话会报错，好像其他的d什么也可以，反正一定要有一个动作
        最好加一个空格，这样区分更加清楚匹配和打印


