定义在类里面的函数是默认inline 的
    可以显式进行inline 声明
        也可以在类外定义的时候再声明内敛
    类内外都可以定义函数
    但要在内部声明

    inline应该定义在和类的定义在一起的头文件里
        因为单独编译的时候就要

this
    永远指向当前对象，当然对象内部的函数使用的时候其实不需要这个，直接就能用
    this 本身是常量指针，也就是这个指针本身不能改动

const 
    成员函数const  type func(xxx) const;
        相当与声明const *const this  底层const是这里的const加上去的
        这样就可以保证不能改变对象了
    常量对象或者常量对象的引用都只能访问常量成员，因为其他成员的隐式this
    指针类型都是不对的，根本用不起来

    可以定义两个函数，一个const版本，一个非const版本，前者const对象的时候精准匹配，后者非const匹配

    返回：
        常量成员函数返回的类型如果是引用或者指针，必须要常量const修饰。不然报错
            const int& func(xxx) const;
            如果是基本类型就不用const了,因为是常量函数返回出来的，所以逻辑上要保证不能修改

类作用域
    类里面的变量是首先处理的，所以定义在函数体后面也没事
    在类外定义的函数需要
    type  class::funcname() const { }这样定义
        函数体内的代码的作用域是类内
    *this 可以返回当前对象

猪：
    函数返回值如果是个引用，就是左值，而赋值语句返回的是左值，
        所以写函数模拟内置赋值符号的时候，因该返回引用

    对象本身是不能cout输出的！！
    
    有些函数逻辑上是操作类的，但不应该是组成部分，这种应该放在类同一个头文件声明，

    函数如果需要io类，只能引用，不能拷贝
        还有，一般输出类函数不负责格式，这个用户自己控制比较好


构造：
    不能const，const属性是构造完成才出现的
    无返回值
    默认构造函数，编译器加的，如果有类内初始值，使用，没有，默认初始化
        如果存在任何构造函数，默认就没了
        如果内部使用了其他类，他们没有默认初始函数，那么整个初始化无法完成

    自定义构造
        name() = default; 这样使用默认构造的行为,类外非inline
        内部直接初始值，这个c++11支持
        构造函数初始值列表
            name(aa,bb,cc):f1(aa),f2(bb),f3(cc) {}  给类内域赋值指定

    拷贝，销毁
        类的默认版本会一次销毁或者复制每个内部成员，需要动态资源的不合适，
            但是vector， string是可以的

访问控制
    public  all process can access
        构造函数要想被使用，必须public
    private  only that object can access
    默认struct是public，每个说明副作用域直到下一个为止或者类尾部
        可出现多次

    class struct:
        唯一区别 前者默认权限private 后者public

    使用了private之后，外部函数想访问内部成员：
        内部任意位置声明 friend funcxxxxx(不受权限影响这句话）
        这个不是函数声明，在外面还要一份的

类型成员：
    public:
        typedef xxx pos;
        using post = xxx;
    需要先定义，然后后面类里面可以使用这个类型，类外面也使用，就隐藏了具体类型的细节

    成员函数也可以重载

    mutable type var;
        这种成员即使是const对象，const函数都可以改变，一般用来记录
        类内初始值：= 或者{}

    一般内部获取的成员返回的都是引用，因为引用可以作为左值被继续执行


类的类型
    没有定义之前可以声明类
        这样可以在函数生命中是用类的引用或者指针
        也可以在类里面使用指针

friend:
    可以是其他类，其他类的函数成员，其他外部函数，或者内敛定义也可以 
        firend由每个类自己控制

    friend class:func()
        有顺序：
            先是func对应的class定义，func声明
            当前被访问的类的声明(要在func使用前声明）

            然后当前类的定义
            然后func函数的定义因为这个时候screen才刚刚成型，才能使用

    friend class xxx; 完全放开访问了

    重载函数必须每个都声明friend

    friend在类内的声明没有任何声明作用，其他内部或者外部函数想要用，必须在之前有过显式的外部生命
