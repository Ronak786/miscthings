定义在类里面的函数是默认inline 的
    可以显式进行inline 声明
        也可以在类外定义的时候再声明内敛
    类内外都可以定义函数
    但要在内部声明

    inline应该定义在和类的定义在一起的头文件里
        因为单独编译的时候就要

this
    永远指向当前对象，当然对象内部的函数使用的时候其实不需要这个，直接就能用
    this 本身是常量指针，也就是这个指针本身不能改动

const 
    成员函数const  type func(xxx) const;
        相当与声明const *const this  底层const是这里的const加上去的
        这样就可以保证不能改变对象了
    常量对象或者常量对象的引用都只能访问常量成员，因为其他成员的隐式this
    指针类型都是不对的，根本用不起来

    可以定义两个函数，一个const版本，一个非const版本，前者const对象的时候精准匹配，后者非const匹配

    返回：
        常量成员函数返回的类型如果是引用或者指针，必须要常量const修饰。不然报错
            const int& func(xxx) const;
            如果是基本类型就不用const了,因为是常量函数返回出来的，所以逻辑上要保证不能修改

类作用域
    类里面的变量是首先处理的，所以定义在函数体后面也没事
    在类外定义的函数需要
    type  class::funcname() const { }这样定义
        函数体内的代码的作用域是类内
    *this 可以返回当前对象

猪：
    函数返回值如果是个引用，就是左值，而赋值语句返回的是左值，
        所以写函数模拟内置赋值符号的时候，因该返回引用

    对象本身是不能cout输出的！！
    
    有些函数逻辑上是操作类的，但不应该是组成部分，这种应该放在类同一个头文件声明，

    函数如果需要io类，只能引用，不能拷贝
        还有，一般输出类函数不负责格式，这个用户自己控制比较好


构造：
    不能const，const属性是构造完成才出现的
    无返回值
    默认构造函数，编译器加的，如果有类内初始值，使用，没有，默认初始化
        如果存在任何构造函数，默认就没了
        如果内部使用了其他类，他们没有默认初始函数，那么整个初始化无法完成

        如果提供的函数全部有默认参数，实际上就是默认构造了 
        使用默认初始化的对象不需要括号的！！！，不然就成了同名函数了，当然同作用与会报错

    委托构造：
        cname::cname(xxxx):cname(xx,xx,xx) {sssssss};
            这样会先运行后面被委托的那个构造函数的所有，然后再执行当前的函数体

    自定义构造
        name() = default; 这样使用默认构造的行为,类外非inline
        内部直接初始值，这个c++11支持
        构造函数初始值列表
            name(aa,bb,cc):f1(aa),f2(bb),f3(cc) {}  给类内域赋值指定

            注意： 对于const或者引用，这个是唯一正确的形式，如果放在函数体里赋值初始化，是错误的
                构造函数初始值顺序要和类内定义顺序一致，因为初始顺序是那个样子的

    拷贝，销毁
        类的默认版本会一次销毁或者复制每个内部成员，需要动态资源的不合适，
            但是vector， string是可以的

    隐式转换
        如果构造函数只有一个参数，也就是调用参数是某个类的时候，可以传入那个类的某个构造函数的参数，
            这时候会自动隐式转换成够造成一个类的！！
            one::one(int a);
            void func(one &);
            int b = 20;
            func(b); 可以的，但是不能填20,那样就转了2次了，先int再构造
            explicit one::one(int a) 
                可以声明组织隐式转换,类外定义的时候不要重复这个声明
            注意：：    而且这个函数今后只能直接初始化，不能拷贝初始化
                    但是我们可以static_cast<classname>(fieldname)强制转换
                标准库中
                    string 有一个char*的构造函数，没有explicit,所以可以直接赋值string给他如果在莫个函数里
                        要求参数string类型的话
                    vector<xx>(n) 这个构造是expliit的所以不能直接，只能构造初始化

访问控制
    public  all process can access
        构造函数要想被使用，必须public
    private  only that object can access
    默认struct是public，每个说明副作用域直到下一个为止或者类尾部
        可出现多次

    class struct:
        唯一区别 前者默认权限private 后者public

    使用了private之后，外部函数想访问内部成员：
        内部任意位置声明 friend funcxxxxx(不受权限影响这句话）
        这个不是函数声明，在外面还要一份的

类型成员：
    public:
        typedef xxx pos;
        using post = xxx;
    需要先定义，然后后面类里面可以使用这个类型，类外面也使用，就隐藏了具体类型的细节

    成员函数也可以重载

    mutable type var;
        这种成员即使是const对象，const函数都可以改变，一般用来记录
        类内初始值：= 或者{}

    一般内部获取的成员返回的都是引用，因为引用可以作为左值被继续执行


类的类型
    没有定义之前可以声明类
        这样可以在函数生命中是用类的引用或者指针
        也可以在类里面使用指针

friend:
    可以是其他类，其他类的函数成员，其他外部函数，或者内敛定义也可以 
        firend由每个类自己控制

    friend class:func()
        有顺序：
            先是func对应的class定义，func声明
            当前被访问的类的声明(要在func使用前声明）

            然后当前类的定义
            然后func函数的定义因为这个时候screen才刚刚成型，才能使用

    friend class xxx; 完全放开访问了

    重载函数必须每个都声明friend

    friend在类内的声明没有任何声明作用，其他内部或者外部函数想要用，必须在之前有过显式的外部生命
        有些如g++没有这个限制 ，但是最好不要以来

在类外，对类成员public的访问：
    eg.  class one {typedef int* ktype;}
        one::ktype xxx,xxx; 这样使用
        其他的就是用 .  ->
        一旦指明了类：：，之后所有部分就可以直接使用类内的东西了，而且优先

        注意返回值不在作用域内，所以返回类型的定义如果特殊，也要class::type

名字查找范围
    对于类外或者类内的所有声明，包括函数的，成员的，都必须是在使用前有过单独声明的，这些看完了，
        才会进行函数提内的解析，例如返回值，体内的使用会查看类范围全体，而不是当前位置之前
    类内类型的定义比如typedef不能和外层重叠，这个和变量定义不一样，不会覆盖，会出错
    ::xxxx
        显式使用外部作用域的值
    如果是定义在外部的函数体，那么除了会查找类作用域，还会查找当前函数体之前，类定义之后的部分

聚合类
    就是所有成员public的类
        这种可以 class name = {xx,xx,xx} 按照定义顺序直接初始化类

字面值常量类
    聚合类如果全部类型值为常量那么就是i字面之长两类
    或者如果有初始值，并且为常量
        然后内部类型使用constexpr的构造函数处理也是可以的
        记住这种函数本身是const的不能改值

静态成员
    成员属于类，而不是对象
    函数没有this，不能用const修饰
    但是可以通过对象访问到这些
    static关键字只能用在类内声明，不能外面定义

    静态函数的定义和成员函数差不多 不用加static
    静态成员的初始化可以在声明的时候，可以不在，
        另外初始化的时候在外面使用 type  class::name  var = xxxx后面这个可以是静态成员函数，可以直接使用

注意：    静态成员一般在类外初始化
            如果要在类内，那么需要必须整形而且constexpr，
            而且最好类外再定义一下，不过这个时候不要赋初始值,也不要static
                使用constexpr int cname::valname; 即可，不然(这个在如果外部函数参数是引用，
                    当然要是const type&,这个时候如果要引用内部的那个只在里面初始化过的值，需要
                    在外部这样没有值声明一下才可以用的

            优点
                因为是对象产生前就存在的，所以可以用在构造函数的默认值或者在类里面直接
                    声明为类对象使用class bar { static bar mem;} 因为对象的产生是在类完成之后，而
                    static的产生在类产生之时
