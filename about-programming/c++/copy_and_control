拷贝控制操作
    构造系够的时候拷贝控制什么

    拷贝构造函数
        classname (const classname&, args=xx)
            第一个参数是类的引用，一般都是const，后面的参数必须有默认值，这样就行了，当作拷贝构造
                因为你要copy你本身如果不是引用，那本身就要调用自己进行copy，循环了
        默认拷贝构造：合成copy构造函数
            编译器一定会有，即使我们自己写了一个
            这个会把非static成员逐个复制，复制的方法由成员自己的copy方法决定
            成员如果是数组，也会挨个拷贝

        直接初始化与copy初始化的区别：
            直接初始化就是将参数去匹配某个构造函数的过程
            copy初始化是把对应对象的field成员逐一拷贝的过程，所以初始化中有等号的和没有的有区别！！

        一般拷贝初始化由拷贝构造或者移动构造完成

        发生时机：
            初始化时候的 =
            传递作为非引用参数的时候
            返回类型非引用的时候
            花括号初始化数组的时候
            容器insert push 使用copy
                emplace使用直接初始化

        限制：
            explicit的构造函数对应的版本不能通过copy的方法执行，只能直接初始化 
            只能把构造好的类复制过去
            其实意思就是这个构造函数必须完全写明白地使用

        绕过？？
            string xx = ("xxxxx") 可以写成
            string xx("xxxx") 绕过拷贝，但是拷贝必须存在，即不能是private
                这样会直接创建对象

    拷贝赋值运算符： classa = classb  的时候会被用到
        Foo& operator=(const Foo &); 这样定义，就是重载赋值运算符
        左侧运算对象就是当前*this

        默认
            把非static对象赋值到左边

    析构函数
        ~classname() 无参数，唯一一个
        注意销毁指针并不会销毁对应的分配空间，需要手动delete！！！
            但是智能指针可以被自动销毁，赞！！
        销毁时机：
            作用域结束
            变量直接，对象系够函数，容器全毁，动态分配的手动，临时对象表达式结束over
                指针引用的外部对象也不会被销毁！！

        这里定义的析构函数，是在系统销毁自动变量之前你可以手动做事情的地方!!

    注意：
        除了这三个，还有移动构造，移动赋值，
        这5个是整体，一般一起使用，不会只用一个

        一般只要是需要析构函数的地方，都会需要拷贝构造和复制构造，因为不然有动态内存分配的问题
        需要拷贝构造的一般也需要赋值构造,但不一定分配了内存

        这些函数都可以 xxxx ()  = default;  如果类外定义的时候这样写，就不是内联函数了
            即都可以赋予默认的合成构造函数，都可以 因为都有默认合成版本

    删除 禁止使用
        xxx = delete; 即可，要第一次声明的时候就协商
        任何函数都可以

        析构函数不能删除，不然无法定义该类型变量，因为不能执行系够了，就不能正常释放变量，所有
        调用他的也不行了,
        但是好像可以用动态分配，但是不能delete

    编译器默认删除某些成员函数：
        某个成员的析构函数不可访问或删除，则类本身析构函数也是删除的
        成员的copy构造是删除的或者系够删除，则类本身copy构造删除
        类有成员赋值删除或者类有引用，const成员，则删除赋值运算
        出现上述情况之一，默认构造函数删除

    private方法
        声明为private的成员不能由外界调用，也就防止了构造，赋值，copy delete, 或编译报错
        private同时只声明不定义，这样成员函数和friend函数调用了就会链接报错

赋值注意：
    赋值运算的实现要注意自我赋值，也就是要先生成临时变量，然后delete 原有，再复制，而不是先delete再直接赋值
        如果两者指向同一个地方，会出错
    如果要自己管理分配释放，可以利用动态内存分配一个地方来管理值，注意自我赋值，所以引用要先增加，再减少再判断
        赋值是增加右边的，减少左边的
        其实最好是share_ptr

swap: 拷贝并交换的函数
    算法使用的swap默认是3次复制，我们可以定义自己的重载它
    friend void swap(class&, class &);
    inline funcname() { using std::swap; swap(xx,xx);}
        这个主要用于优化
        注意应该using std::swap, 再swap(xx,xx) 而不是直接 std:;swap(xx,xx)
            后者强制调用系统swap，前者会判断是否元素本身具有swap函数可用！！！！

        赋值的异常安全
            可以利用swap实现赋值的异常安全
                只要赋值参数是类本身的值而不是引用,然后进行交换，
            因为这个过程中产生了一次复制，对于自我赋值也没有影响

移动构造
    std::move(oldeme) 这个写在可以放构造参数的地方，
    这样可以避免拷贝，而是应该只复制了内部指针
        这个整个返回的值作为移动构造函数的参数，当然只有定义了移动构造函数才可以这样用

    新标准容器，stirng , shared_ptr, 支持移动和copy
    unique_ptr ,io类只支持移动

    右值引用 int &&a = 24 + 2;
        和左值引用相反，一般绑定在短暂的值上面
        比如计算表达式这种不能当左值的都可以作为右值或者是const 引用

        注意：
            变量引用是左值，所以不能给右值引用绑定右值引用

        std::move 绑定右值引用到左值上 in <utility>
            int &&r3 = std::move(r2); 注意std:: 显式使用
        承诺
            必须保证move之后原对象只能被赋值或者删除，不能使用

    移动构造函数
        和copy一样地一个是引用,右值引用
            函数内部记住要重置源那边，因为那边没用了

    移动赋值
        和前面的赋值一样使用，记住修改掉元数据
            移动后的元对象有效，但是值不保证

    注意 (class &) noexcept   这个因为移动不应该抛出一场
        这样可以减少一些处理，放在初始化列表和参数列表之间
        必须指定在声明和定义的时候
        一般不抛出异常，因为移动中异常会出现两边都不一致的行为
            所以需要保证不会发生的前提下才使用移动，而且要声明
            如果要分配新内存，可能会异常，这时就不用noexcept
        Message::message(message &&m): content(std::move(m.content)) 这样使用

        在没有移动构造和移动赋值的时候，会使用对应的copy版本
            前提是那个版本你使用了const的参数！！！


        默认定义：
            如果你定义了copy构造，赋值，析构函数之一，就不会定义默认移动构造，而是使用他们
            另外，如果内部某个类型不能移动,不能拷贝，那么也不会自动生成。 赋值运算同理
            如果显式=defaul声明，那么如果无法生成，=default 就相当与=delete
            如果析构函数函数或不能访问，也不能定义移动构造
            如果成员const，不能移动复制

        定义了自己的移动构造和移动赋值，那么合成的copy版本会被删除，注意了，一定要手动定义
            copy会在没有移动的时候代替他

        移动赋值运算符：
            这个接受的如果是非引用成员，那么在接受的时候就是一个拷贝或者移动操作，具体看你的实际对象是左值还是
                右值，然后才是调用对应的函数里的内容，
                一般使用的都是拷贝构造，除非精确匹配移位的右值类型额
            使用std::move 返回右值引用
                可以移动构造，classname T(std::move(t2));
                    移动赋值  classname T = std::move(t2);

        移动迭代器：
            在使用迭代器的地方
            make_move_iterator(begin()) 得到移动迭代器，这个传递给
                uninitialized_copy之后，会对每个元素解引用返回右值，这样如果有移动构造函数，
                就会使用那个处理
                可以提升性能，但是要确保安全

        
    一般做法
        一般函数也可以有两个版本的
            const的左值以及非const的右值版本
            一般需要抽取数据的版本使用右值，否则使用左值

        强制左值右值 引用限定符
            type func(xxxx) const &;或者 &&;
                首先那个const表示常量函数，&表示当前对象是左值对象的时候调用，&&表示右值对象的时候调用
            引用限定副对于所有同名函数必须都加或者都不加

            使用不同限定的版本，就可以按照目前值的属性形态进行不同的动作了
        注意：
            这个限定的你的当事人也就是左边那个对象的状态，如果是函数返回值如func().memeber()这样使用
            就可以用这里的限定符号来分离辨认状态，如果只有左值函数，也是可以直接使用的，兼容了右值，
            如果只有右值函数，是不能使用左值的功能的

            实测g++里面左值限定副会兼容右值，不能做到阻止，还是再写个右值函数吧
