拷贝控制操作
    构造系够的时候拷贝控制什么

    拷贝构造函数
        classname (const classname&, args=xx)
            第一个参数是类的引用，一般都是const，后面的参数必须有默认值，这样就行了，当作拷贝构造
                因为你要copy你本身如果不是引用，那本身就要调用自己进行copy，循环了
        默认拷贝构造：合成copy构造函数
            编译器一定会有，即使我们自己写了一个
            这个会把非static成员逐个复制，复制的方法由成员自己的copy方法决定
            成员如果是数组，也会挨个拷贝

        直接初始化与copy初始化的区别：
            直接初始化就是将参数去匹配某个构造函数的过程
            copy初始化是把对应对象的field成员逐一拷贝的过程，所以初始化中有等号的和没有的有区别！！

        一般拷贝初始化由拷贝构造或者移动构造完成

        发生时机：
            初始化时候的 =
            传递作为非引用参数的时候
            返回类型非引用的时候
            花括号初始化数组的时候
            容器insert push 使用copy
                emplace使用直接初始化

        限制：
            explicit的构造函数对应的版本不能通过copy的方法执行，只能直接初始化 
            只能把构造好的类复制过去
            其实意思就是这个构造函数必须完全写明白地使用

        绕过？？
            string xx = ("xxxxx") 可以写成
            string xx("xxxx") 绕过拷贝，但是拷贝必须存在，即不能是private
                这样会直接创建对象

    拷贝赋值运算符： classa = classb  的时候会被用到
        Foo& operator=(const Foo &); 这样定义，就是重载赋值运算符
        左侧运算对象就是当前*this

        默认
            把非static对象赋值到左边

    析构函数
        ~classname() 无参数，唯一一个
        注意销毁指针并不会销毁对应的分配空间，需要手动delete！！！
            但是智能指针可以被自动销毁，赞！！
        销毁时机：
            作用域结束
            变量直接，对象系够函数，容器全毁，动态分配的手动，临时对象表达式结束over
                指针引用的外部对象也不会被销毁！！

        这里定义的析构函数，是在系统销毁自动变量之前你可以手动做事情的地方!!

    注意：
        除了这三个，还有移动构造，移动赋值，
        这5个是整体，一般一起使用，不会只用一个

        一般只要是需要析构函数的地方，都会需要拷贝构造和复制构造，因为不然有动态内存分配的问题
        需要拷贝构造的一般也需要赋值构造,但不一定分配了内存

        这些函数都可以 xxxx ()  = default;  如果类外定义的时候这样写，就不是内联函数了
            即都可以赋予默认的合成构造函数，都可以 因为都有默认合成版本

    删除 禁止使用
        xxx = delete; 即可，要第一次声明的时候就协商
        任何函数都可以

        析构函数不能删除，不然无法定义该类型变量，因为不能执行系够了，就不能正常释放变量，所有
        调用他的也不行了,
        但是好像可以用动态分配，但是不能delete

    编译器默认删除某些成员函数：
        某个成员的析构函数不可访问或删除，则类本身析构函数也是删除的
        成员的copy构造是删除的或者系够删除，则类本身copy构造删除
        类有成员赋值删除或者类有引用，const成员，则删除赋值运算
        出现上述情况之一，默认构造函数删除

    private方法
        声明为private的成员不能由外界调用，也就防止了构造，赋值，copy delete, 或编译报错
        private同时只声明不定义，这样成员函数和friend函数调用了就会链接报错

赋值注意：
    赋值运算的实现要注意自我赋值，也就是要先生成临时变量，然后delete 原有，再复制，而不是先delete再直接赋值
        如果两者指向同一个地方，会出错
    如果要自己管理分配释放，可以利用动态内存分配一个地方来管理值，注意自我赋值，所以引用要先增加，再减少再判断
        赋值是增加右边的，减少左边的
        其实最好是share_ptr

swap:
    算法使用的swap默认是3次复制，我们可以定义自己的重载它
    friend void swap(class&, class &);
    inline funcname() { using std::swap; swap(xx,xx);}
        这个主要用于优化
        注意应该using std::swap, 再swap(xx,xx) 而不是直接 std:;swap(xx,xx)
            后者强制调用系统swap，前者会判断是否元素本身具有swap函数可用！！！！

        赋值的异常安全
            可以利用swap实现赋值的异常安全
                只要赋值参数是类本身的值而不是引用,然后进行交换，
            因为这个过程中产生了一次复制，对于自我赋值也没有影响

移动构造
    std::move(oldeme) 这个写在可以放构造参数的地方，
    这样可以避免拷贝，而是应该只复制了内部指针
        这个整个返回的值作为移动构造函数的参数，当然只有定义了移动构造函数才可以这样用

    新标准容器，stirng , shared_ptr, 支持移动和copy
    unique_ptr ,io类只支持移动

    右值引用 int &&a = 24 + 2;
        和左值引用相反，一般绑定在短暂的值上面
        比如计算表达式这种不能当左值的都可以作为右值或者是const 引用

        注意：
            变量引用是左值，所以不能给右值引用绑定右值引用
