1 c++是一个语言联邦
    C的过程编程
    面向对象编程
    模板编程
    stl库的使用规范 
        这四个各不相同

2,常量
    使用const enums 而不是#define 
        在类里面的static记住如果赋值的是整形常量，那么可以在类里面就直接赋值，
            但是这种的需要在外面再定义一下，这个时候的定义不需要初始值
        enum
            除了上面的做法，还可以enum {xx=20}; 这样，然后直接在类作用域里面使用enum
                好处是这个值没有地址，可以对外屏蔽！！
        宏函数不如模板函数好！！

3 尽量使用const
    如果你不想值被改变，如参数，如返回值，
        特别是重载运算符好的返回值，有些不需要有左值功能，就应该const
    const 函数
        两个版本，一个成员是const函数，另一个是非const函数，两个返回值，参数都一样，
            这种情况下是可以重载的

    两种const：
        bitwise const：就是完全const
            这种字面上的就是内部元素本身不能修改，加const可以保证
        logical const：保证内部逻辑上也不修改 mutable
            这种如字符指针内容也不许修改，同样可能还需要修改某些内部状态，
            这样在const的情况下还需要在某些参数上加上mutable

    const and nonconst
        两种代码，造成重复，共同部分的调用也有重复，所以。。。
        最好是让nonconst 调用const版本，最后使用 const_case<type&>来转换

        注意：
            需要两个转化，一个是返回值，一个是传入的this指针只想的对象,需要变成const static_const<xxx>

4  使用前初始化 建议全部在成员初始化列表里面
    内置类型， 自己小心，声明的时候就初始化吧
    对象，确保构造函数会初始化每个成员
        func():a(b),c(d) {} 这才是初始化，放在构造里面就不是初始化了,那个时候默认初始化结束了，
            其中后面的每项构造可以括号为空
            尽量都写吧，即使不需要显式赋初始值, const类型一定只能这样，所以全部这样最了当
        注意：
            在一个构造里，初始化内部另一个对象的时候，可以使用{} 或者（）来传入它的元素来构造
            内部的那个成员代表的对象，也可以直接传对象给他调用copy构造

        不过有些变量显式不显式初始化都差不多好

    non-local static:
        只要不是函数里定义的static，都是non local的
            这样的缺点是，不同文件的non local static初始化的顺序是未定义的
            所以做法是把所有的non local static放入函数内，让其返回引用使用，
            因为规定了函数内变量的初始化会在函数第一次调用的时候执行
        多线程还是会有竞争问题，这时最好是还是单线成的时候先调用函数一次初始化好

5 默认构造等。。。
    默认情况下会有默认构造，copy copy赋值， 系够函数4个声明， 注意系够是 non-virtual的
        使用到的时候才会定义出来
    成员的copy使用他们自己的copy构造函数

    对于copy赋值函数，如果成员是引用，或者基类是private的copy赋值或者不支持赋值，那么
        当前类拒绝自动构造copy赋值函数，需要你手动写

    拒绝copy和赋值：
        1,使用private 声明，同时不实现，这样friend和成员也不能调用成功了，但是对后者只有link的时候才会报错，
            要想编译报错，需要设计一个baseclass，然后private 他们，你的函数继承他们，最后实现你的类即可
        2使用新标准的 func(xx)= delete;

