1 c++是一个语言联邦
    C的过程编程
    面向对象编程
    模板编程
    stl库的使用规范 
        这四个各不相同

2,常量
    使用const enums 而不是#define 
        在类里面的static记住如果赋值的是整形常量，那么可以在类里面就直接赋值，
            但是这种的需要在外面再定义一下，这个时候的定义不需要初始值
        enum
            除了上面的做法，还可以enum {xx=20}; 这样，然后直接在类作用域里面使用enum
                好处是这个值没有地址，可以对外屏蔽！！
        宏函数不如模板函数好！！

3 尽量使用const
    如果你不想值被改变，如参数，如返回值，
        特别是重载运算符好的返回值，有些不需要有左值功能，就应该const
    const 函数
        两个版本，一个成员是const函数，另一个是非const函数，两个返回值，参数都一样，
            这种情况下是可以重载的

    两种const：
        bitwise const：就是完全const
            这种字面上的就是内部元素本身不能修改，加const可以保证
        logical const：保证内部逻辑上也不修改 mutable
            这种如字符指针内容也不许修改，同样可能还需要修改某些内部状态，
            这样在const的情况下还需要在某些参数上加上mutable

    const and nonconst
        两种代码，造成重复，共同部分的调用也有重复，所以。。。
        最好是让nonconst 调用const版本，最后使用 const_case<type&>来转换

        注意：
            需要两个转化，一个是返回值，一个是传入的this指针只想的对象,需要变成const static_const<xxx>

4  使用前初始化 建议全部在成员初始化列表里面
    内置类型， 自己小心，声明的时候就初始化吧
    对象，确保构造函数会初始化每个成员
        func():a(b),c(d) {} 这才是初始化，放在构造里面就不是初始化了,那个时候默认初始化结束了，
            其中后面的每项构造可以括号为空
            尽量都写吧，即使不需要显式赋初始值, const类型一定只能这样，所以全部这样最了当
        注意：
            在一个构造里，初始化内部另一个对象的时候，可以使用{} 或者（）来传入它的元素来构造
            内部的那个成员代表的对象，也可以直接传对象给他调用copy构造

        不过有些变量显式不显式初始化都差不多好

    non-local static:
        只要不是函数里定义的static，都是non local的
            这样的缺点是，不同文件的non local static初始化的顺序是未定义的
            所以做法是把所有的non local static放入函数内，让其返回引用使用，
            因为规定了函数内变量的初始化会在函数第一次调用的时候执行
        多线程还是会有竞争问题，这时最好是还是单线成的时候先调用函数一次初始化好

5 默认构造等。。。
    默认情况下会有默认构造，copy copy赋值， 系够函数4个声明， 注意系够是 non-virtual的
        使用到的时候才会定义出来
    成员的copy使用他们自己的copy构造函数

    对于copy赋值函数，如果成员是引用，或者基类是private的copy赋值或者不支持赋值，那么
        当前类拒绝自动构造copy赋值函数，需要你手动写

6拒绝默认构造
    拒绝copy和赋值：
        1,使用private 声明，同时不实现，这样friend和成员也不能调用成功了，但是对后者只有link的时候才会报错，
            要想编译报错，需要设计一个baseclass，然后private 他们，你的函数继承他们，最后实现你的类即可
        2使用新标准的 func(xx)= delete;

7 virtual dtor
    如果不需要继承，可以使用final
    虚系够函数，用处是动态绑定，也就是派生类被赋值给基类的时候可以正常释放，不然未定义结果
        当然是需要当作基类的时候，至少有一个虚函数的时候才这样，不然就是浪费空间，必将虚这个操作也是要有
            数据空间预留的
    注意：
        有些class 是base，但不设计为用来动态析构函数，所以也不需要
        还哟标准容器不设计为可以继承，注意！！系够不是virtual的

8 析构函数与异常
    系够不应该有异常抛出，所以可能异常的函数在外部调用，让客户自己解决，而系够要对
        客户未处理，这个情况进行处理，发现的话要捕获异常或者直接std::abort()

9 构造中的virtual
    构造的时候使用的virtual会被绑定到basetype上，所以不要！！
    析构函数也不要使用，因为会绑定错误

    要多注意，因为可能有内部调用的函数间接调用了
        或者干脆不用虚函数，而是初始化的时候委托给基类初始化,直接传数值进去

10 重载运算符返回左值
    return *this, 
    这样可以和内部类型一样连等于

11 拷贝赋值中的自我赋值
    问题在于赋值过程中一般要先释放自己本来的动态空间，而如果是自我赋值，或者new新空间的时候发生异常，
        那么删除的就没了，原来的也没了，
    解决方法是先利用copy构造复制一份，或者直接passby value而不是引用 然后：
        1 swap， 返回，临时变量会自己销毁
        2 手动new 赋值完毕后再delete 旧的 ， 推荐1

12 copy的时候
    记住要复制每个元素，新加元素的时候要注意，使用基类的时候，记住可以在初始化列表
        手动调用基类的复制构造函数

13 资源管理
    把资源管理的放到对象里面，delete放在析构函数里面，然后利用share_ptr uniq_ptr来管理
    是比较妥当的，而不是让客户调用这手动delete
    share可以传入delete函数的
        对于需要实现创建，后面赋值，但是析构函数早就定下来的，可以初始化nullptr
    可以在复制的时候管理引用数量，可以自己定制delete的动作
        不过对于动态数组，不能使用默认的shareptr的析构函数
        有了这个传入的delete，建造的类可能不需要delete函数了，就让他利用默认的就行了

15隐式转换
    operator type() {} 这样的成员函数返回type类型，但是赋值的时候容易出问题，比如建错对象竟然能正常赋值，
        所以显式的使用。get之类的比较好

16 new delete new[] delete []
    形式不要弄混，特别是使用typedef的时候

17 func(share_ptr<type>(new xxx), call())
    这种可能造成泄漏，因为内部new和外部构造，以及call三者顺序不一定，如果先new，在call，然后异常了，那么就没有
        构造了，就泄漏了，所以最好在外部new完了变成shareptr之后传入，
            或者可以make_shared<>(xx,xx,xx) 这样构造

18 让接口易用，不被误用
    如果传入的多个参数容易误用，错值或者位置颠倒，一个办法是给每个参数包装一个类型
        内部做检查，而且类型本身也可以防止错位，

        还可以利用某些静态成员函数来返回类型的对象，这样就限制了类型类型可以返回的值
    接口的一致性
        和类似的对象的用法一致，让客户少记住东西

19 考虑你设计的type/class
    如何创建和销毁（operator new operator new[] ...)
    初始化和赋值的差别
        后者涉及销毁以前的对象
    const 和非const版本的共用
    pass value or pass ref
    约束合法值以及i异常的处理
    继承与被继承的处理 virtual。。
    类型转换的允许与否
        operator type() ,  explicit声明
    应该使用的member以及重载的操作符，应该拒绝的操作=delete or private 并且不定义
    权限控制private public friend
    定义新type 还是新模板更合适？ 如果想要的其实是一个族的类
    定义新的type或者仅仅需要一些新功能，定义几个nonmember函数即可？

20 pass by const ref instead of value
    ref 保证不会产生对象切割如果传给base class
    const保证不会被修改
    对于pass value的不昂贵可行的只有内置类型以及stl的迭代其和函数对象

21 不要顽固返回引用
    有些操作比如乘法，要返回内部值的时候，不应该返回引用，不应该使用static（如果操作了两次，
        然后比较结果，会永远想等），改返回值的时候就返回值，不应该引用不要吝啬

22 public protected private
    private应该用于成员， protected并不比public好多少，一旦改变，都会影响客户或者不可知的继承类，所以坚持private

23 non-member non-friend member
    使用nonmember函数可以增加封装性，因为可以访问的权限变小了，对于多种的便利函数，其内部的基本功能放在类里面，
        但是便利的组合功能应该放在外面，然后可以根据不同种类的便利功能，放在同一个namespace但是不同的头文件里面，
        按需include，这样更好扩展性

24 如果要为某个函数的所有参数提供可以类型转换的可能空间，应该使用
    nonmember函数，比如operator*(xx,xx) ,而且不要firend，而是应该使用公共接口

25 swap
    函数不支持部分特例化，就是创建标准函数的同名模板，但是这个模板只对某个特定类型的创建（这个特定类型本身是个模板），
        这种是部分特例，不允许对函数这样，必须只能特例化到一个固定的类上面
        这种情况下最好是重载那个模板，让参数特殊一点
    注意：
        std库不允许添加新的模板，只能特例化

    默认swap
        这个就是普通的3步复制
    外部定义的交换函数
        这个直接交换内部成员，但是需要friend，不好
    class内部定义一个成员函数进行交换
        然后外部再定义一个函数调用之
        所以这个对于要定义函数的时候是推荐的
    如果要定义函数模板，对一个模板类进行swap操作，那么就不行了
        这个时候会部分特例化函数，不允许，所以选择重载swap，但是std空间不允许新的类的定义，
        所以应该在你自己的空间定义一个同名模板函数，
        最后查找名字的时候，会在global，然后是实参所在空间，然后才是标准空间，然后特例化的
    注意在你调用swap的地方using std:;swap
    这样才会去找标准空间，还有不能std::swap(xxx)，这样会跳过其他空间的查找 

26 延后变量的定义（声明在标准库里默认定义的对于对象和内置类型）
    这样可以减少构造和析构函数的使用如果中途有其他退出点
   对于循环，如果赋值成本比构造系够要小，可以放在外面定义，但是名字空间污染，否则应该在内部定义
