exception
    不断向外寻找，不匹配组合总就是终止
    析构函数里面的异常应该自己处理，因为异常的时候会销毁对象调用系够，这个时候再异常
        就会出错，构造的一场要自己处理！！不然对象不完整

    throw 抛出的是静态编译类型表达式，也就是集成体系的派生部分会被截断

    catch的时候如果不是引用，改变的是副本
        派生类异常也可以赋值给基类，注意了这种赋值如果是非引用，会被截断，
        所以throw一个会被截断，因为throw一个就是复制一个出去
            而如果catch引用，就是动态绑定了
        建议：
            引用类型

        catch匹配从上到下，除了指针函数数组的 const的 派生类的转换，其他都不行

        重新抛出，
            在catch里才会有用，不然终止程序，只要throw;即可，会被上层捕获，
            用引用，不然修改无效

        catch(...)
            捕获所有异常 一般没啥用，throw即可

        构造函数的异常
            两种，1 参数本身初始化过程中的异常，属于调用者去catch
                  2 开始构造之后（包括参数赋值那部分） func(xx,xxx,xx):try {xxxxx} catch(xxx) {xxxx} 即可

        noexcept(true/false)可选:
            在const & &&之后， final =0 override之前， 表示确定不会抛出，会优化
            如果觉得不应该出现异常，或者无法处理出现的异常，也是一样的，这样之后异常了会直接terminate
            noexcept(g()) 表示判断g是否抛出异常，不会去执行的
                一般再套一层用来维持两个函数异常抛出的一致

            函数指针和指向的函数，虚函数的积累和拍神陪的关系，
                都是左边的必须范围比右边的大，也就是左边抛出异常，右边才能抛出异常，也可以不抛出

            拷贝构造
                成员和基类承诺noexcept，才会noexcept

        异常层级
            1 exception
            2 bad_cast, bad_alloc 这三个有默认构造，不需要参数, runtime_error, logic_error 要参数
            3 runtimeerror:
                overflow_error
                underflow_error
                range_error
            logic_error
                domain_error
                invalid_argument
                out_of_range
                length_error
            what 虚函数，各自初始化返回的内容

            可以集成标准异常


命名空间
    namespace xxxx { } 
        内部可以放所有可以出现在全局空间的内容
        空间本身的名字要在当前空间唯一
        可以在其他空间定义，但不能在class或func里
        后面没有分好 ！！！！

        使用namespace_name::varname 访问

        空间可以不连续定义每次定义都是添加到已有的或者新建一个

        一般不把include放在命名空间，因为这样就是就相当于嵌套了一个空间

        在命名空间外层可以定义内部的函数，和类外定义函数一样的，但是只能外面，不能是另一个不相关的空间里
            模板特例化必须在同一个空间

        全局命名空间，默认声明的
            ::member 即可

        嵌套
            可以

        内联空间：
            inline namespace xxx 
                好处是可以和当前空间完全融合，好像没有另建空间一样，一般用于新版本的内容更新

        未命名的空间
            namespace {} 之在单个文件有效
            作用域和该空间所在作用域一致，直接访问
                相当与文件静态变量

    别名：
        namespace bias = originname; 简短一些,可以多个
        using std::xxx
            引入一个名字，会掩盖当前域内名字，引入直到using作用域结束
            还可以引入基类的名字 放在类里面
        using namespace xxx; 
            不能在类里面 可以在函数里
            这个和上面那个using声明不同，这里的是命名空间的展开，所以会有名字的二义，
                如果要使用同名，不会掩盖，而是要显式指定空间名，不然报错
                同时内部其他作用域的东西如果相同会自动隐藏
        
        建议
            函数空间使用using声明，就是第一种
            命名空间使用using namespace xx 可以的，但记住会在本地空间展开所有变量

    查找名字
        从内到外，但是类会先初始化变量再调用的注意

        特例：
            函数如果参数有类类型，查找的时候不仅会找当前的空间和父空间，
                还会查找类所在的空间，所以我们可以直接使用 cin >> cout << 

        友元
            对于友元函数，如果实参的类型所在的空间正好包含友元函数的生命，那么可以免去显式声明，不然找不到

    函数与命名空间
        using能增加候选函数

        using ns::funcname; 会把作用与内的重载函数都添加进来，当作匹配的候选
            如果有一样的和当前空间内，会报错
        using namespace xxx;
            之后，同名函数不会报错，而是我们要显式指示名字空间

多重继承： 每个有自己的限定符号，根据出现的顺序初始化
    如果使用继承构造函数
        using base::base; 不能有两个以上相同的类中有相同的构造，
            这种时候，必须手动定义一个构造对于每个一样的 
    拷贝复制都是先对基类再自己（默认的版本）

    名字重复，
        如果寻找的名字在当前类里面没找到，在多余一个基类里找到，会报错，需要显式xxx::name指定

    默认情况下多个层次里如果有相同的对象被继承，会产生多个副本对象的

    虚基类 虚派生
        作为派生类，使用虚继承，有这个的两个以上派生类虚继承了同一个基类，然后
            再来一个类继承了这两个派生类，这种情况下，对于那个共同的基类，只有一个副本
            版本，就不会有两个了

        public virtual , virtual public 都可以 ,写在派生列表

        可见性以最靠近你的类的最高
            解决二义性最好是在每个类中新定一个同名的，整合一下

        虚基类的构造
            总是出现在非虚之前，与是不是直接继承无关，如果没有，会导致默认构造的执行
                多个按照派生列表
