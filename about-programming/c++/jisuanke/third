类函数的引用问题
    const 类实例只能调用const变量
    对类函数的修饰
        const &  &&
        如果& 那么右引用对象无法使用这个函数，反之依然
        所有的重载函数的 & &&修饰要有，& &&都行

    构造函数
        右值不写不会有
        右值写了左值和缺省都没了，所以要写三个一起写
        什么都不写，默认有左值
        右值引用的好处是保证不能让左值调用，还可以避免返回return的时候的复制
            需要move支持

调用函数，作为lambda
    class xxx { operator()(xxx,xxx){}};
    sort(beign, end, xxx{}} 即可，因为返回了一个可调用对象，
        不管是啥，可调用就行了


    lambda接受&&
        本来传进去的要么是& ，要么=， 但是如果对象是一个右值，
            那就不行了，这个时候可以使用 [name=var] 来传值，
            名字左右也可以一样，不会重叠，lambda是新环境的，
            然后name = move(var)就可以传入move进去，不会复制了
        注意function《xxx》本身可以接受参数的，然后传给内部
            的lambda直接使用

        在lambda里如果传入临时变量，利用function方法&&参数类型先捕获
            然后里面name=move(var)穿进去使用
        如果使用类的函数方法，则可以传入&&，内部利用funciton传入&&
            这个内部直接作为左值传入，然后class内部move参数来初始化变量，
            也可以利用forward传&&入class，不过记住这都是临时变量，
            都是作为参数的类生成的，只要引用不断，就不会销毁
            右值引用主要用来消除中间的多次赋值

析构函数
    右值引用构造的const & 类型会在最内部被析构掉

    c++里，如果用一个变量来接一个返回值，或者返回值是另一个函数的参数，
        那么函数内部返回前return的可以是要作为变量赋值的或者作为另一个函数的
            要接受参数直接返回
                string func() {return "zxxxx";}这是优化
                这样不会调用两次构造，而只哟一次

placement new
    在你提供的位置上传见对象
        xxx = new(buf) class; 
        释放
            xxx->~xxx() 这样这个位置还能给别人用,buf要多一个sizeofint的大小，用来存大小的
    全局new是不能重载的，
        operator new用来给类自己分配内存的，不是全局通用的
