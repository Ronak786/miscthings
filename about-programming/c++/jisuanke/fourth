new delete
内存泄漏查看 visual studio
    #define _CRTDBG_MAP_ALLOC
    #include <stdlib.h>
    #include <crtdbg.h>
    #define NEW_WITH_MEMORY_LEAK_CHECKING new(_NORMAL_BLOCK, __FILE__, __LINE__)
    #define new NEW_WITH_MEMORY_LEAK_CHECKING

    放文件开头
    _CrtDumpMemoryLeaks();
    放主函数结尾return之前

    这样，运行完后，会显示new malloc 没有free delete的所有位置等信息

继承
    dynamic cast
    static cast  两者都可以用于父子类之间转换，
        但是前者更好，如果确实不可以转，会返回nullptr，后者不检查
        没有继承关系这两种都是不可以转的，第二种会编译报错

    子类使用virtual函数：
        xxx override；表明确实是覆盖父类函数, 可以不写virtual
        构造 subclass(xxx):superclass{xxxx}初始化
            如果父类没有默认构造，那子类一定要这么写，子类也不会有默认构造，
                写=default也没有

        纯虚函数 =0; 子类一定要实现这个

    调用重载函数的的时候类别一定要对上

设计模式初探
    visitor访问者模式
        好处是增加新的东西比dynamiccast之后到处ifelse方便，
            只要在子类调用的地方放入外置的访问器类，内部根据不同的子类设计不同的重载函数，
                然后统一在每个子类里有一个函数以这个类或者这个访问其类的子类的指针为参数，
                1,继承访问器类可以实现不同子功能
                2 只要每个子类统一一样调用就行了，这样就可以用父类指针搞定这件事情了
