c++ 里struct没有独立名字空间，和c不一样，所以不能struct foo foo;
struct 默认是public，继承也是默认public
数组的使用
    array xxx[]{xxxxx} 可以直接初始化的
        初始化是是可以初始化引用的
    构造：
        这种不带等号的{}初始化成为 universal construction
        当没有构造函数的时候,这种初始化会按顺序初始化每个成员
        尽量不要在构造函数体才输出话变量
        尽量使用{}而不是（）！！！
            后者用来批量初始化设置数目

        默认初始化
            默认情况下没有初始化的在类里面初始化为0
            可以在变量上直接{} 初始化
            如果类中某个成员没有默认构造，那默认不会生成构造，=default 等同于 =delete
            初始化尽量使用{} 而不是等于的形式, char *buffer{new char[1]{'\0'}};, int length{0}

        移动，复制构造默认生成，除非不能，如果有一个，其他都不会有的
            赋值函数= 注意判断是否是本身，设计delete过程


    右值左值
        右值临时变量，可以const type &a = 1绑定, 作用是减少复制过程，
                右值进来的保证了你可以把内部摘出来，而不会导致错误，原类里保证了会做处理
            &&接受临时变量, 所谓临时对象，基本指的就是放在等号右边的那些构造出来的对象
                如 a = classname(var); 这个就会调用移动构造，因为构造完了就没用了
            但是之后内部再传递的时候，会变成左值，
            std::move 制造右值
        
            右值传惨中的作用
                右值作为参数，那么传进去左右值属性，const属性完全不变，很有用,左值不行的

            什么时候是右值
                return 局部变量的时候
                表达是返回值类型的时候
                返回右值的时候 但是T&&不一定是右，会折叠

        注意：
            在使用模板的时候，如果是T&&作为参数，
                整个这个参数会被适配成传进来的参数类型，
                    就是如果传左值进来，那么T是 type&,
                    因为这样 type& && 折叠成 type &，就匹配传进来的了
                如果进来的是&&， 那么T 就是type，因为这样就是type&&
                    直接对头了！！！
            而模板是可以匹配任何具体类型组合的！！
        forward move 返回右引用(forward保持原来）

        forward 用于参数是 T&&的形式的时候，会传递原来的样子&&或者&都可
            forward(type) 返回type&&
            forward(type&) return type&
        但是记住到了函数体里面，都是左值，因为进入后有名字了，
            只有在函数标签上才是右值，作用是保证你可以剪切，我马上会删除
            自己

        右值的传递一定需要move，直接传，即使本身是&&，进去函数也是&

    总结forward move
        forward 需要参数形式类型声明的时候是T&&形式，然后会原样穿进去
        move 把左值传成右值,表示这个左值我不需要了，你可以当右值干掉
            进去后两者都有名字，变成左值
    explicit:
        单参数非复制构造函数，防止隐式转换，也就是如char* 转换成string
