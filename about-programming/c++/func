auto var
    所谓自动，在块里面，经过的时候创建，到达块尾删除，迭代第二遍继续创建
static var
    就算在局部，程序期间都存在

函数声明：
    如果永远用不到函数，可以不定义

    建议使用引用或者常量引用如果不需要改变，使用拷贝太浪费
    初始化形参的时候因为是初始化，形参里的顶层const当时不会有用
    同样的两个函数，如果参数仅仅是const不一样，会被忽略
    不能把const类型传给非const类型
        字符串也只能传递给常量引用！！
        其实常量引用的范围更大，虽然不能改变，注意母函数使用的是否是const类型

    记住初始化：
        底层const的存在不能被忽略，所以const不能赋值给非const
        const 引用可以给字面值，但是非const的不行
        引用本身必须类型匹配，人家const自己也要const

    数组传参：
        如果使用引用，缺点是引用必须明确声明大小，这样参数就绑定了数组的大小，这个不好
        传递begin 和end的指针确实不错

        func(int arr[][10])  func(int (*arr)[10])多维数组第二唯独开始不能省略，因为这个是
            转换出来的类型
            在参数里的地一个维度会省略，写了也没用的注意，除非用的是引用

        main(int ac, char*av[]) 和C一样

    全部一样类型的可变参数
        initializer_list<T>  lst  参数常量不可变
            lst.size  .begin .end  lst(lst2)
        func(other args, xxx,xxx, {aa,bb,cc,dd}, other args) 传到一个花括号里面

    不一样的可变，使用varargsC库，但是这个只能用于C和C++通用的部分

return
    if void ,return;  or return func; 这个func要是void类型的

    返回值的类型必须和声明的一样或者可以转换
    返回的时候会在调用点创建临时变量收容，所以不要返回局部变量的指针或者引用！！
        字面值如果是函数内定义的，也会是局部临时的，也不可以引用！！但可以直接传值

    返回值，如果是个引用，那就是左值，这个时候可以直接func(xx.,xx) = xxxxx;赋值
        不是引用就不行,因为引用可以改变本身嘛

        可以返回列表，如果返回值的定义类型是例如vector<int>之类的，return {1,2,3,4};

    int main;  include <cstdlib>  return EXIT_SUCCESS EXIT_FAILURE;

    返回数组的指针
        int (*funcname(paramlist))[arr维度，不能省略]
        这个复杂了，返回的是一个数组的指针，有另外一种生命方法
        auto func(param) -> int(*)[10]  这个方便 尾置返回类型
        or  
            int a[10];
            decltype(a) * func(param);

重载：
    名字相同，参数列表不同
    main 不能
    顶层const忽略
    底层const可以用来区分
        可以利用const_cast<xxx> 来转换某个类型成非const类型
            注意改变的是底层const

        当多个重载都可以匹配，都不是最佳匹配的时候，会报错

    作用域：
        如果在内部作用域重新定义了一个重载函数或者同名变量，那么就会隐藏外部所有同名函数，
            只在内部寻找 注意！！

    确定使用哪个函数：
        1 找到候选函数集合：当前可见，名字相同
        2 选出可行函数： 数量一样，类型可转换
        3 最佳匹配存在的话，（如果不需要类型转换）直接使用（即使有默认参数）
        4 如果不能，分析每个参数，如果有一个函数：
            每个匹配都不劣于其他函数，至少一个匹配优于其他就成功，不然报错

        精确匹配：
            完全相同
            数组或函数类型转换成指针
            添加或删除顶层const
        2 const转换匹配
        3 类型提升匹配
        4 算出转换或指针转换匹配
        5 类型转换匹配

        注意数字都会默认提升到int而不是short，除非显示生命short类型的实参传进去
            算数转换不存在级别，只要转换都一样

默认参数
    可以设定默认值，但是从那个以后到末尾必须都有默认值,
        调用的时候必须从地一个参数开始指定，不能跳着，所以要设计好顺序！！
    声明：
        多次声明可以各自添加默认参数值，但是必须保证当前添加的时候当前右边的已经被之前的声明添加过了
        默认参数在声明的时候就绑定解析了，就是绑定地址了，但是实际计算值是在调用的时候！！

内联函数
    inline type func (xxx) 这个是编译器请求，可能忽略
        过大的可能不支持
constexpr  type func() {xxxx}
    只要参数以及返回值都是字面类型就行了

    内敛和constgexpr可以多次定义的，而且编译的时候要展开，所以在各自头文件定义最好了，而不是淡淡声明，但是
        多个定义要一样


assert
    in cassert header 这个是宏，所以不用std:;assert, 直接用即可
    assert(expr)

    NDEGUB 
        默认未定义，若定义，assert不生效
        __FILE__ __LINE__ __TIME__ __DATE__
        __func__ 函数名

函数指针
    由返回值和形参共同决定
    p = funcname
    p = &funcname 一样的
    调用也可以不解引用直接用

    如果函数本身有重载，指针必须精确匹配，不然报错

    函数类型放到参数里面自动变成指针
    可以typedef 可以decltype的到的都是函数类型，除非显式使用*表示指针 !!!

    返回值必须写是函数指针，不会自动转化，可以哦那个typedef或者using 这样方便
