auto var
    所谓自动，在块里面，经过的时候创建，到达块尾删除，迭代第二遍继续创建
static var
    就算在局部，程序期间都存在

函数声明：
    如果永远用不到函数，可以不定义

    建议使用引用或者常量引用如果不需要改变，使用拷贝太浪费
    初始化形参的时候因为是初始化，形参里的顶层const当时不会有用
    同样的两个函数，如果参数仅仅是const不一样，会被忽略
    不能把const类型传给非const类型
        字符串也只能传递给常量引用！！
        其实常量引用的范围更大，虽然不能改变，注意母函数使用的是否是const类型

    记住初始化：
        底层const的存在不能被忽略，所以const不能赋值给非const
        const 引用可以给字面值，但是非const的不行
        引用本身必须类型匹配，人家const自己也要const

    数组传参：
        如果使用引用，缺点是引用必须明确声明大小，这样参数就绑定了数组的大小，这个不好
        传递begin 和end的指针确实不错

        func(int arr[][10])  func(int (*arr)[10])多维数组第二唯独开始不能省略，因为这个是
            转换出来的类型
            在参数里的地一个维度会省略，写了也没用的注意，除非用的是引用

        main(int ac, char*av[]) 和C一样

    全部一样类型的可变参数
        initializer_list<T>  lst  参数常量不可变
            lst.size  .begin .end  lst(lst2)
        func(other args, xxx,xxx, {aa,bb,cc,dd}, other args) 传到一个花括号里面

    不一样的可变，使用varargsC库，但是这个只能用于C和C++通用的部分

return
    if void ,return;  or return func; 这个func要是void类型的

    返回值的类型必须和声明的一样或者可以转换
    返回的时候会在调用点创建临时变量收容，所以不要返回局部变量的指针或者引用！！
        字面值如果是函数内定义的，也会是局部临时的，也不可以引用！！但可以直接传值

    返回值，如果是个引用，那就是左值，这个时候可以直接func(xx.,xx) = xxxxx;赋值
        不是引用就不行,因为引用可以改变本身嘛

        可以返回列表，如果返回值的定义类型是例如vector<int>之类的，return {1,2,3,4};

    int main;  include <cstdlib>  return EXIT_SUCCESS EXIT_FAILURE;

    返回数组的指针
        int (*funcname(paramlist))[arr维度，不能省略]
        这个复杂了，返回的是一个数组的指针，有另外一种生命方法
        auto func(param) -> int(*)[10]  这个方便 尾置返回类型
        or  
            int a[10];
            decltype(a) * func(param);
