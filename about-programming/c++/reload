重载
    运算符参数按顺序，除了函数运算符，其他不能有参数
    但是类成员运算符号参数少一个，因为默认有个this左边的
    必须至少有一个类成员参数，this也算
    + 00 * / % ^
    & | ~ ! , = 
    < > <= >= ++ -- << >> == != && ||(这两个和逗号还有&不建议，因为没有短路属性,还有有默认系统属性）
    += -= /= %= ^= &=
    |= *= <<= >>= [] () -> ->* new new[] delete delete[]

    不能重载:: .* . ?:

    调用方式
        date1 + dat2
        operator+(data1,data2)
        data1.operator+=(data2) 对于类
        cout << class
            的输出应该定义一个外部函数 ostream& operator<<(ostream& os, class &);

    必须成员函数
        = [] () ->
        复合赋值建议成员
        ++ -- * 等建议
        具有对称性的建议不要成员 + * == < > | ^

输出输入
    一般是外部函数，返回stream引用，使用stream引用
    尽量不要做格式化，影响后续操作

    重载输入
        需要处理输入出错的情况，将对象置于有效状态

    ==
        外部定义，应该同时定义！=，而且应该其中一个利用另一个取反，
        应该具有传递性
    < > 
        这一类主要是《 会被算法用到，但是有些类没有明确的大小关系，只有不等关系
            不一定要强行定义
    =
        赋值，比如拷贝赋值，移动赋值，还可以列表初始化赋值 class& operator=(initializer_list<string> li)定义一个
            必须是类内定义

    []
        下表运算，一般定义const和非const两个版本的函数，
        对于const对象只能通过const函数操作并返回const值
        返回引用

    ++ --
        前置
            operator++  返回修改后的引用
        后置
            operator++(int) 参数用来区分的，不要用,定义的时候也不用命名，因为不用
            返回值，而不是引用,before modified
        显式调用
            前 a.operator++()
            后 a.operator++(0)
        *
            返回引用
        ->
            这个特殊，如果使用的对象本身是指针，正常指针操作，不管这个重载，
            如果是个重载了符号的类，记住这个没有参数的，要返回一个指针，然后利用这个
                指针会再做常规的->运算
        ()
            函数对象，根据参数类型数量可以多个
        lambda
            相当与只有一个函数重载的类
            默认const参数，如果声明可变，就可以不是const
                如果有捕获列表，相当与类里面还有成员,函数调用也有参数

        
        标准定义的命名操作符 模板
            in <functional>  plus<T>  negate<T> divides<T> .....
            这些用于算法函数，
            sort(begin, end, greater<string>())就行
            还有可以利用这个比较指针，默认是不能比较无关指针的
            less<string*>() 就行

        调用类型：
            int (*)(int, int)
            [](int,int){} 注意，每个lambda都是不同的类型，不能赋值到同一个函数指针上面

            in <functional>
            function标准类型
                function<T> f(obj);
                function<T> f(nullptr);
                f(args) 调用
                f 当作条件判断 非空为真

                T 是 int(int,int) 这种形式的函数模板
                    这个可以存储所有同样调用形式的函数，包括 上面说的不同类型

                    注意对于重载函数的类，要用class()来获得可赋值进去的函数
                    对于有歧义的名字，最好先定义赋值一个函数指针再填进去
