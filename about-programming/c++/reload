重载
    运算符参数按顺序，除了函数运算符，其他不能有参数
    但是类成员运算符号参数少一个，因为默认有个this左边的
    必须至少有一个类成员参数，this也算
    + 00 * / % ^
    & | ~ ! , = 
    < > <= >= ++ -- << >> == != && ||(这两个和逗号还有&不建议，因为没有短路属性,还有有默认系统属性）
    += -= /= %= ^= &=
    |= *= <<= >>= [] () -> ->* new new[] delete delete[]

    不能重载:: .* . ?:

    调用方式
        date1 + dat2
        operator+(data1,data2)
        data1.operator+=(data2) 对于类
        cout << class
            的输出应该定义一个外部函数 ostream& operator<<(ostream& os, class &);

    必须成员函数
        = [] () ->
        复合赋值建议成员
        ++ -- * 等建议
        具有对称性的建议不要成员 + * == < > | ^

输出输入
    一般是外部函数，返回stream引用，使用stream引用
    尽量不要做格式化，影响后续操作

    重载输入
        需要处理输入出错的情况，将对象置于有效状态

    ==
        外部定义，应该同时定义！=，而且应该其中一个利用另一个取反，
        应该具有传递性
    < > 
        这一类主要是《 会被算法用到，但是有些类没有明确的大小关系，只有不等关系
            不一定要强行定义
    =
        赋值，比如拷贝赋值，移动赋值，还可以列表初始化赋值 class& operator=(initializer_list<string> li)定义一个
            必须是类内定义

    []
        下表运算，一般定义const和非const两个版本的函数，
        对于const对象只能通过const函数操作并返回const值
        返回引用

    ++ --
        前置
            operator++  返回修改后的引用
        后置
            operator++(int) 参数用来区分的，不要用,定义的时候也不用命名，因为不用
            返回值，而不是引用,before modified
        显式调用
            前 a.operator++()
            后 a.operator++(0)
        *
            返回引用
        ->
            这个特殊，如果使用的对象本身是指针，正常指针操作，不管这个重载，
            如果是个重载了符号的类，记住这个没有参数的，要返回一个指针，然后利用这个
                指针会再做常规的->运算
        ()
            函数对象，根据参数类型数量可以多个
        lambda
            相当与只有一个函数重载的类
            默认const参数，如果声明可变，就可以不是const
                如果有捕获列表，相当与类里面还有成员,函数调用也有参数

        
        标准定义的命名操作符 模板
            in <functional>  plus<T>  negate<T> divides<T> .....
            这些用于算法函数，
            sort(begin, end, greater<string>())就行
            还有可以利用这个比较指针，默认是不能比较无关指针的
            less<string*>() 就行

        调用类型：
            int (*)(int, int)
            [](int,int){} 注意，每个lambda都是不同的类型，不能赋值到同一个函数指针上面

            in <functional>
            function标准类型
                function<T> f(obj);
                function<T> f(nullptr);
                f(args) 调用
                f 当作条件判断 非空为真

                T 是 int(int,int) 这种形式的函数模板
                    这个可以存储所有同样调用形式的函数，包括 上面说的不同类型

                    注意对于重载函数的类，要用class()来获得可赋值进去的函数
                    对于有歧义的名字，最好先定义赋值一个函数指针再填进去

        类型转换
            一般定义为const函数，因为不改变原来的
            类型转换运算符：
                必须是成员函数 ,没有返回值，参数空
                    operator int() const {} 就是int(class)的时候的返回值
                    在需要的时候会进行转换，比如 class + 42这个时候如果定义了int的转换，就会使用

                注意这个和构造不一样
                    class=42 这个是用42作为参数隐式构造一个对象然后拷贝赋值
                一般不用，但是可以定义到bool的类型转换，使得可以用于条件判断，但是注意
                    这使得也可以用于位移等运算符，可能会出现变成整形1然后参与计算的情况
推荐！！                显式类型转换
                    explicit xxxxx, 
                    这样只能static_cast<int>使用了，但是安全
                        但是用于条件判断仍然隐式，好用！！
                要注意二义性问题，就是两条路径都能都能转换的额问题，这个时候只能显式转换，不然报错
                    比如定义了两个算数转换，他们本身类型可以自己转换就会报错
                        其中标准类型转换比如整形提升之类的更优先
                    如果两个类都有同样参数的构造函数，使用隐式一步转换的额时候会出现错误，要显式，避免
                    标准转换不会对二义性造成影响，二义还是二义
                        标准转换只有当请求同一个用户定义类型才有用
