继承：
    class a : public b, public c    public是限定副，表示可以完全当作基类使用
    virtual func xxxxx;     表示必须子类实现的函数
        子类实现的时候使用override表示我覆盖了虚函数
        动态绑定，如果函数是基类引用参数，可以传入基类，派生类，调用到对应函数

基类：
    一般定义虚成员函数（可以自己实现的），虚析构函数=default 然后由其他人去实现
    需要子类实现的写成虚函数，，除构造和静态外都可以标记，
        调用的时候，绑定指针或者一可能用额，都可以动态绑定不同子类的
        virtual 只能在类内声明，如果虚，那么子类里默认也是虚，当然子类里可以不加
            只要不是virtual声明，都会在编译时解析，naluhodo～～～

    访问控制：
        派生类可以访问基类的共有成员，如果基类用了protected,那么只有派生类可以，其他外人不能访问
        
派生类列表
    class name : public A,public B
        这里public private protected这三个的意思是从基类继承的成员是否对当前类用户可见

    虚函数如果要重新定义，要声明的，不然默认直接继承
    后面新规范应该最后面加上override
    可以利用基类的指针引用绑定派生

    构造
        在初始化列表里 constA(xxx):const(b),c(x) 这样子初始化
             否则默认初始化

    静态成员：
        如果private，派生无法访问，其他权限类似
    声明：
        不需要基类列表
        如果想要作为基类用，必须已经定义,而不是单单声明
    final
        class xxx final: xxxx {} 
            声明final表示当前类不能被继承

    类型转换
        派生可以赋值给基类的指针，引用，智能指针也可以
        动态类型
        静态类型，
            就是实际传入的类型和声明的类型，指针引用可以不一样，其他要一样
        不能反响转换
            可以转成子类的方法：
                dynamic_cast 动态运行时在检查
                static_cast 直接不检查，直接转

        特殊转换
            基类构造函数如果用了引用可以传派生类进去
            重载了赋值用了引用也可以，原理是引用可以隐式转换！！

虚函数： 只有它能被覆盖
    每个必须定义，因为动态绑定，无法知道什么时候会调用
        子类默认使用父类的版本的
            自己定义的话必须完全匹配，除非返回的是类本身的引用或者指针，这个时候可以适应性修改
        只有在动态引用的时候才会动态解析其他时候都是可以确定调用那一个的
        
        如果覆盖的函数形参不同，实际是新函数，所以override的用处就是让编译器告诉你你参数搞错了！！

    final 的类和函数都不能覆盖
        虚函数上一层定义了final，那下一层就不能覆盖了，只能使用他的
    默认参数
        派生 基类可以不同，但是实际使用的默认参数是具体对应的那个类的，如果动态绑定用的就是基类的
            所以最好默认参数都一样

    回避：
        baseP->baseclass::func() 
        baseRef.baseclass::func() 使用baseclass：：的作用域运算符

    纯虚：
        没有意义的函数，func() = 0; 
            可以在类外定义的 也可以不定义
        含有纯虚的是抽象基类，不能有对象，
            可以被继承，集成者需要定义那些函数，不然仍然抽象基类
            但是抽象类的指针引用可以引用那些集成出来的其他类的对象的（和java像）

    重构，就是重新构建内部类的继承结构，但是接口是不变
        表示不能调用
            这样强制使用某个类中的虚函数的版本，主要用在虚函数内调用基类需函数的处理中

访问控制
    protected
        就是派生对象以及friend而言是public，其他对象而言是pirvate
        注意只能通过派生对象去访问，不能直接访问基类对象！！

