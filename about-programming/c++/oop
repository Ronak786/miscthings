继承：
    class a : public b, public c    public是限定副，表示可以完全当作基类使用
    virtual func xxxxx;     表示必须子类实现的函数
        子类实现的时候使用override表示我覆盖了虚函数
        动态绑定，如果函数是基类引用参数，可以传入基类，派生类，调用到对应函数

基类：
    一般定义虚成员函数（可以自己实现的），虚析构函数=default 然后由其他人去实现
    需要子类实现的写成虚函数，，除构造和静态外都可以标记，
        调用的时候，绑定指针或者一可能用额，都可以动态绑定不同子类的
        virtual 只能在类内声明，如果虚，那么子类里默认也是虚，当然子类里可以不加
            只要不是virtual声明，都会在编译时解析，naluhodo～～～

    访问控制：
        派生类可以访问基类的共有成员，如果基类用了protected,那么只有派生类可以，其他外人不能访问
        
派生类列表
    class name : public A,public B
        这里public private protected这三个的意思是从基类继承的成员是否对当前类用户可见
        protect:  成员，友元，派生类

    虚函数如果要重新定义，要声明的，不然默认直接继承
    后面新规范应该最后面加上override
    可以利用基类的指针引用绑定派生

    构造
        在初始化列表里 constA(xxx):const(b),c(x) 这样子初始化
             否则默认初始化

    静态成员：
        如果private，派生无法访问，其他权限类似
    声明：
        不需要基类列表
        如果想要作为基类用，必须已经定义,而不是单单声明
    final
        class xxx final: xxxx {} 
            声明final表示当前类不能被继承

    类型转换
        派生可以赋值给基类的指针，引用，智能指针也可以
        动态类型
        静态类型，
            就是实际传入的类型和声明的类型，指针引用可以不一样，其他要一样
        不能反响转换
            可以转成子类的方法：
                dynamic_cast 动态运行时在检查
                static_cast 直接不检查，直接转

        特殊转换
            基类构造函数如果用了引用可以传派生类进去
            重载了赋值用了引用也可以，原理是引用可以隐式转换！！

虚函数： 只有它能被覆盖
    每个必须定义，因为动态绑定，无法知道什么时候会调用
        子类默认使用父类的版本的
            自己定义的话必须完全匹配，除非返回的是类本身的引用或者指针，这个时候可以适应性修改
        只有在动态引用的时候才会动态解析其他时候都是可以确定调用那一个的
        
        如果覆盖的函数形参不同，实际是新函数，所以override的用处就是让编译器告诉你你参数搞错了！！

    final 的类和函数都不能覆盖
        虚函数上一层定义了final，那下一层就不能覆盖了，只能使用他的
    默认参数
        派生 基类可以不同，但是实际使用的默认参数是具体对应的那个类的，如果动态绑定用的就是基类的
            所以最好默认参数都一样

    回避：
        baseP->baseclass::func() 
        baseRef.baseclass::func() 使用baseclass：：的作用域运算符

    纯虚：
        没有意义的函数，func() = 0;   继承的时候，如果不实现也是可以的，只要不产生类就行了
            可以在类外定义的 也可以不定义
        含有纯虚的是抽象基类，不能有对象，
            可以被继承，集成者需要定义那些函数，不然仍然抽象基类
            但是抽象类的指针引用可以引用那些集成出来的其他类的对象的（和java像）

    重构，就是重新构建内部类的继承结构，但是接口是不变
        表示不能调用
            这样强制使用某个类中的虚函数的版本，主要用在虚函数内调用基类需函数的处理中

访问控制
    protected
        就是派生对象以及friend而言是public，其他对象而言是pirvate
        注意只能通过派生对象去访问，不能直接访问基类对象！！

    派生类限定副是用来限定外部用户对于基类的访问的，和派生继承类本身的访问控制无关
        据我判断。类的限定是从大到小的
            如果当前public基类，那么就看基类内部的限定，如果protected，那么默认就是protected，即使
                基类是public，那么也会变成protected
        同时还能控制继承自派生类的新类的限定

    转换与访问控制
        1,只有public 继承，用户代码才能类型转换
        2 无论怎么继承，成员和友元都可以转换，随意使用
        3 D只有共有或保护继承B，D本身的派生类的友元才能使用D向B的转换

    友元
        关系不能继承，每个类控制自己的友元关系
            并且利用派生类，可以访问友元对应的他的基类部分的成员

    using:
        改变权限：
            比如你私有继承一个类，那么里面的成员对于你的派生类来说就是不可访问的了
                但是你在你的对应作用域下使用 using baselass:field;
                 之后，这个成员（变量或函数）就可以被当作是在你当前作用与下生成的了
            using只能对自己能访问到的名字用
    默认：
        默认的限定符也和struct class有关一个public 一个private

作用域：
    基类的作用与是最外面的，从最内部的最上层派生类开始往下
    派生类同名隐藏基类
        使用classname::field来显式使用

    查找名字规则：
        首先根据声明的静态类型在那个类中找对应的名字，找不到直接报错
        找到后再看是否是虚函数，而且是否使用是否使用了引用作为参数，
            如果都是，那么就是动态类型的调用
        如果有一个条件不是，就是静态类型的普通调用

        注意内曾作用域如果使用了外层的名字，不会形成重载，而是直接覆盖掉了，不会再去找外层的名字
            就算参数类型都不一样也会覆盖
            i.o::func()这样调用
            所以需函数必须完全一样，不然就是隐藏，也就没办法动态绑定使用了相当与派生类默认了一个但是被隐藏的需函数
                当然你可以另外定义继承的需函数，不太好

    重载：
        名字相同而参数不同
        如果要使用重载的函数，那么不能是在派生类中定义一个，因为这样会全部隐藏，
            要么全部覆盖，要么一个都不覆盖，
            还有一种方法，使用using clsname::funcname;就行了
                只要一句，所有重载的都过来了
                

虚析构函数：
    这样如果使用了动态绑定，也可以正常系够了
        使用=default; 可以不用去定义 析构是倒过来的，先最上层类,最后基类
    如果定义了，就不会有默认的移动构造,派生类也不会有

拷贝控制
    如果基类的拷贝，默认，拷贝复制，系够是删除的，那么派生的默认也删除
    如果积累没有系够，那么派生类合成的构造默认， 拷贝都没了,因为不能销毁，就不该创造
    基类的移动或析构函数没有，那么本身也不行
        由于移动在定义系够后就没了，默认使用拷贝，如果删除了，也没了(删除继承自基类）

    对于这些，可以使用default显式定义,当然要可行，不然默认就是default就是delete(比如定义系够的情况就可以用这个）

    派生类的拷贝控制函数：
        一般要在初始化列表调用基类的初始化对应构造函数，如果没有的话，默认就是默认构造了
        赋值函数：
            函数体内base::operator=(rhs) 这样子调用进行基类部分的赋值，然后再接着操作
                不管是基类是默认版本还是手写版本都这样
    系够函数只要管自己，
        基类部分会自己调用

    注意
        在构造和系够中执行的虚函数是对应类的版本，这个时候不动态绑定

继承构造函数：
    只能直接继承，不能继承默认，移动，拷贝构造
    方法：
        using baseclass::baseclass;
            会自动构造构造函数和基类的版本的几乎一样，但是是当前函数的构造函数
        继承过来的private constexpr的属性不变
            如果有默认参数，会有多个版本，每个版本有一个默认参数??具体一样？？
            如果自己定义，会覆盖一部分
            默认拷贝移动不会继承，自己定义
            
            这个和using重载函数差不多

容器
    存放具有集成关系的不行，因为直接赋值，调用的时候实际调用的是基类的版本
    但是可以存放基类的指针，
        注意，智能指针也可以基类派生转换！！

    这个显式写在函数里封装不好，
        可以隐式，但是问题是内部makeshared分配内存的时候必须知道子类的大小而不是积累，所以我们必须
            为每个类定义两个clone函数，分别用在copy和move上，返回一个新对象，然后用这个传给makeshared去用，
            这个clone是虚函数，利用了我们上面说的返回值是本类的引用或指针的情况，需函数可以返回值不一样的特征

最后的query项目
    Query 接口类，
        这个用于创建每个需要查询的单词的类，
            所有的符号的作用，都是将一个或者两个query类的eval的结果进行与或，
            最内部的是wordquery的类，这个的eval会进行实际的textquery类的查询操作，其他的都是
                对中间结果的与或非操作
            这个query接受一个查询单词作为初始化，而textquery类的初始化是要在外边单独弄的，最后作为
            参数传入这个查询系统

            每个运算符返回不同的查询操作类，这些类都继承自同一个基类

        再好好看看
