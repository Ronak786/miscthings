关键是对可变状态的管理
同步使用synchronized 放在方法前面
    对象锁
        java每个对象有一个对象锁，而锁的区域是线程，所以同一个线程可以重入
        1, synchronized funcname() {}
        2, synchronized (this) {} 这样子放入代码块

java.util.concurrent.atomic
    这个里面有原子的基本和引用类型,可以用于单个变量

同步方法
    一种是所有状态放在类里面，更新使用同一把锁，放在一个地方
    每个同步块都要小一些，不要占用整个函数(目的是达到某种简单与性能的平衡）

    读写顺序需要同步，内部指令可能重拍，可能读到非法值

    优点：
        同步了之后可以保证每次读写的所有线程可见性，因为每个要处理的线程
        都要锁定后访问

atomic
    jvm中，对于64位数字，存也会上下32位分开，所以需要volatile或者锁
volatile
    只能保证可见性


发布
    将一个对象给到当前作用域外部或存储一个外部的引用
    方法
        存在公共变量里面
逸出
    给出了一个不该给出的引用
    不要在构造过程中使用this
    不要在构造中创造线程！！

线程封闭
    各自的变量只由各自线程自己使用
    ad-hoc:
        完全有程序来维护封闭而不是系统，这种比较脆弱
    栈封闭
        使用局部变量保存类引用y
    threadlocal
        这个类定义方法initvalue，然后每次一个线程执行，如果不存在对应线程
        上的值，就用这个方法初始化一个，存在就直接使用get方法的返回
        这个是线程特定的，可以用来隔离
    不可变对象y
        这个肯定安全了，使用final
    final对象是不需要同步的，安全的

安全发布
    使用静态初始化函数初始化
    保存引用到atomic volatile等域，
    保存到final中
    保存造锁保护的地方
    对于事实不可变的，可以通过安全发布
    可变对象要安全发布，还要线程安全或锁保护起来
    访问安全：
        线程封闭 ,单线程拥有可变
        安全共享 内部实现线程安全，通过共有接口大家访问
        只读共享
        保护对象，使用锁

私有锁
    定义一个object，然后synchronized (obj) {} 
        好处是锁封闭
