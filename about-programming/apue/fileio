unistd:
	STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO

getrlimit: see sys/resource.h supported list of resources, sysconf and pathconf see man page
open_max: (I am 1024)
	getrlimit or use  sysconf's OPEN_MAX to get
	WE DON'T NEED FILE OFFSET 64 BECAUSE WE ARE 64BIT SYSTEM!!
no_trunc: this controls if file name too long will throw an exception, set one will and is default
open, openat: (openat used to open file based on a dir)
	openat fd: 
		1 if path absolute, ignore fd
		2 if fd has string, look for base on that
		3 if fd is AT_FDCWD, just like open(2)
	options: O_EXCL used with O_CREAT, to make sure only one time create
			CLOEXEC	close on exec(), 
			O_DIRECTORY  only can open directory, otherwise error
			O_NOCTTY ,do not open as a controlling terminal for this process
			o_append  append after last bytes
			o_truck if open write only or rw, will truncate to zero length
			sync, wait until physical io return, also attribute write return
			dsync, only wait data write, and attr write only if that attr will affect your
				data write(eg,size)
			rsync, the same as sync

			use openat to open relative to cur dir, be security

			becareful NAME_MAX (255), POSIX_NO_TRUNC will check if name is too long
					and error will return 
			O_NONBLOCK do not block when open fifo  char file  or blk-device
			o_nofollow  if is a symbolic link ,not follow 
	perfer:
		creat ==  open(fd, O_RDWR | O_CREAT | O_TRUNC, mode)

close:
	also release record locks on that file, 
		when exit, all fd's will be closed
	close may error, but you must not close twice, that error just used to warn data might loss
lseek:
	off_t is signed type, and return cur pos, 
	THIS CAN BE NETATIVE, so if return -1, should check errno number

