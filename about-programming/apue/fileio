unistd:
	STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO

system conf:
	getrlimit: see sys/resource.h supported list of resources, sysconf and pathconf see man page
	open_max: (I am 1024)
		getrlimit or use  sysconf's OPEN_MAX to get
		WE DON'T NEED FILE OFFSET 64 BECAUSE WE ARE 64BIT SYSTEM!!
	no_trunc: this controls if file name too long will throw an exception, set one will and is default
	_POSIX_V7_LP64_OFFBIG  using getconf, decide we have int32bit, long ptr, off_t 64bit in spec SUS
open, openat: (openat used to open file based on a dir)
	openat fd: 
		1 if path absolute, ignore fd
		2 if fd has string, look for base on that
		3 if fd is AT_FDCWD, just like open(2)
	options: O_EXCL used with O_CREAT, to make sure only one time create
			CLOEXEC	close on exec(), 
			O_DIRECTORY  only can open directory, otherwise error
			O_NOCTTY ,do not open as a controlling terminal for this process
			o_append  append after last bytes
			o_truck if open write only or rw, will truncate to zero length
			sync, wait until physical io return, also attribute write return
			dsync, only wait data write, and attr write only if that attr will affect your
				data write(eg,size)
			rsync, the same as sync
			O_CRATE 和O_excl 一起用可以保证操作在创建文件如果不是的话，会失败，这样就可以原子创建了
				如果使用link在这样打开的文件上，link会失败
			mkdir(xx xx)这个是目录的原子创建

			use openat to open relative to cur dir, be security

			becareful NAME_MAX (255), POSIX_NO_TRUNC will check if name is too long
					and error will return 
			O_NONBLOCK do not block when open fifo  char file  or blk-device
			o_nofollow  if is a symbolic link ,not follow 
	perfer:
		creat ==  open(fd, O_RDWR | O_CREAT | O_TRUNC, mode)

close:
	also release record locks on that file, 
		when exit, all fd's will be closed
	close may error, but you must not close twice, that error just used to warn data might loss
lseek:
	off_t is signed type, and return cur pos, 
		offset can be very big, so when return will get 0
	use offset 0 from seek_cur to get current pos
	THIS CAN BE NETATIVE, so if return -1, should check errno number
		also if can not seek(pipe ...) will return -1
	must use rdonly  wronly rdwr(one of three)
	if using O_APPEND,then all write will append, and lseek only can control read
		append is atomic 组合的到末尾，然后写，只不过pos不变
	同样pread pwrite也是到指定位置，改动，然后pos不变。 append and these are all 原子操作！！
		但是如果使用append，那么pwrite也会放到最后的

read: 
	return type is sign long, count is unsigned long
	SIZE_MAX is in stdint.h  SSIZE_MAX just define bits/types.h

BUFSIZ system default is 8192
		这个和你的文件系统的blk配合使用，每次取相似数量的大小会有最高效，还要注意
			去掉缓存的影响

file descriptor:
	every process has a table of fds=> 
	every fd have a pointer to a file detail struct (to record modification status of own process)=>
	every file strct point to a real files inode for data reference
	when dup, two fd share one file table
	when fork, two fd from diff process share one filetable

dup: 
	duplicate old to the lowest available
dup2:
	duplicate old to new, if new is open, first close(atomic) FD_CLOEXEC这个fd的属性会dup的时候去掉
fcntl( F_DUPFD )is the same as dup and dup2,使用最后的参数控制行为
	这个两种函数来自不同的规范

sync: just queue io for writing
fsync(fd): wait until that fd's content write into disk
fdatasync(fd): wait until data is on disk
