并发
    有硬件上的多核或者多处理器的真并发，多核有点假
    还有软件上的短时间多次切换形成的假并发

途径
    说到途径，并发可以通过单进程多线程，或者多个进程，
        不同之处在与是否共享资源
    多进程额缺点
        需要多个固定的进程空间开销，互相通信缓慢，收到os的进程间保护影响
        优点是更安全,可以通过网络远程多进程
    多线程
        共享地址方便，但是要维护冲突访问，开销小
目的
    分离多个不同的功能需要

种类
    任务并行 一个任务切成几分并行处理
    数据并行  不同部分数据的代码部分并行处理，这些都是会有问题的

注意
    编译的时候需要-lpthread !!!
    收益不足不该用线程，开销过大也不该用，过多的线程会耗尽地址空间
    线程切换也要尽量避免

标准
    标准库提供了线程模型，有高级抽象，也有底层工具，一般用抽象即可

include <thread>
std::thread t(func, param...); //start
    成员函数：
        t(&classname::funcname, classname()(or objname or &objname), param)
    初始化是一个复制参数，然后给函数传递的过程，所以如果传递的是数组指针或者数组头，
        那么复制过去就是数组头，这样就可能导致本地销毁后崩溃, 应该转换之后再调用thread构造
    传引用：
        线程会把你传入的值copy一份再给里面的函数，所以你需要传引用进去，用std::ref(var),
    移动：
        std::move() 移动而不是拷贝参数，也是可以的
        std:;thread 类型是一个可移动类型，所以可以通过std::move()的方式进行赋值，会调用移动构造的
            对于已经转移掉的变量，可以被另外赋值，但是，没有转移的不行，因为本身需要被系够，这个不允许
            不请不出的被覆盖掉值的
            同样可以利用函数返回值返回临时变量的对象return std::thread(func),
                或者返回其他已经生成的对象，也会默认调用移动构造的！！
                但是传参数的时候需要move或者临时变量
            vector 移动敏感，可以直接把临时变量的thread类型push进去
t.join()  //wait to stop
t.joinable() true  can join, false can not join

    这里传入的是可调用类型，重载函数符号的对象本身也可以传入
        注意可以先定义传变量，或者传classname(),也是可以的,其他地方的也是一样的
    结束之后要join，如果结束之前thread对象被销毁，会调用terminate异常 出去的
    结束之前要注意线程有没有访问local变量，不能让local函数先结束，
    名字解析问题:
        在初始化的时候不能放入临时变量，也就是函数生成的变量，因为
        这个会被c++变成函数声明，而不是变量定义;
        绕过：
            可以使用大括号，后者多一层括号避免误解析

join
    傻等，意味着释放，变量也释放了注意，不能再用了
    异常安全：
        需要异常的时候保证join，可以把线程的创建放到一个类里面去
        变量的销毁是逆序的，在栈上
detach
    这个意思是不能再对他进行join了，但是main结束仍然会kill这个进程，所以仍然没了,
        线程不会继续的
        !t.joinable()
        分离后只能确定最后main结束了他会结束
