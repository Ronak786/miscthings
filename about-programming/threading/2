竞争
    必须注意，调试看不出来，负载大就有了
无锁编程
    比较困难，就是每个人看到的都是稳定的状态，中间态不出现
软件事务内存
    事务要么冲突失败，要么完成，这里不讨论STM

mutex
    std::mutex,
    lock, unlock,
    建议使用std::lock_guard<some_mutex> xxx, 这个变量会在初始化的时候控制加锁，delet的时候解锁
        作为local变量更加方便
    建议：为了加强保护，除了mutex，还要注意成员函数不要返回或者以保护的数据作为参数,或者存储在外部变量中

    但是mutex不能解决几个原子操作组合的问题，空隙间还是可以被竞争的

stack的一些问题
    每个操作包括构造都需要互斥量的保护，但是top pop ， empty pop之类的组合仍然会有问题
        还有如return pop的时候，由于需要拷贝构造，如果这个时候异常那么已经pop，却丢了数据，
        如果采用top，再pop又会有竞争
        如果采用引用获取，需要类型相关函数，以及赋值操作的实现，总之不一定通用
