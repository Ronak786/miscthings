Main 要大写
使用某个空间里的类，就在外面using xxxx；
自己也要放在一个空间里面

格式字符串
  {index, aligment:Cxx} 最后的表示输出格式，xx为需要的数字数量，具体各个不同，一般指的是小数点之后，
      没有的话就是general ， %g的形式
      e r p n x g f d c , r 表示保证parse方法转回数字和原来一样
      
///  文档注释
//  /* */ 普通注释

数据类型
schar char uint ushort ulong double float class interface delegate enum dynamic string object 最后三个是特殊类型
引用类型是实际存储堆中，一个引用在其他地方指向它

class
	包含字段，用于存储，默认有默认值
	方法 ，包含函数调用
	自动变量所有都不会自动初始化的

	访问修饰符
		private public  protected inernal (protected internal)

	默认权限：
		private，默认成员，方法都是私有的记住
		就是只能从当前类内部的函数访问
	名称嵌套
		本地变量是不能嵌套同名的，和类的字段倒是可以同名
	const 常量
		必须初始化，不能引用对象，因为编译而不是运行时要决定好值，
			只能null了
	传参
		ref 传引用 ，需要调用，声明函数的时候都用ref
		ref的话，一定要传入的是变量，不能是单单的计算式子或者值
		想要方法内部改变整个原先的引用，就要用到ref，不然
		只不过是复制了引用变量，

		输出参数
			out type var 声明
			out var 调用， 和ref一样都需要
			传入之后内部一定要先初始化，赋值，才能读取，
				外部直接放进去
		
		参数数组
			params type[] name 的形式
			type要自己定，必须是最后一个参数，内部只能同一个类型，
			必须只能有一个
			传入的时候，使用
				1，逗号间隔的一组值
				2，type[] arr = {}, 传入arr即可，
				注意不用修饰params
				注意空参数也是可以传给数组的，那样就是么有传入
				注意数组传的时候是复制当前值的
					除非是使用整个数组名传入的

			数组创建
				type[] name = new type[] {xxx};
		for each:
			foreach(type x in xxx)
				xxxxxx;

	方法重载
		同名，但是参数不同，返回值不算
	命名参数
		放在位置参数后面， var: val 的形式即可
	可选参数
		值类型可以 ， 引用，out param都不可以
		引用只能null的可以，
			可选参数的意思是可以附一个默认值记住，不是单单说
			可以省略，这样parmas也算了
		顺序：
			必选(包括命名）， 可选， params
			省略参数必须从尾部开始省略
				不然要用命名参数消除歧义

类
	成员声明 [特性】 【修饰符】 核心声明
		public static之类都是修饰符
	静态成员，	
		用类来引用，如果有表达式，会在初始化任何静态成员前计算
		必须用类名访问
	成员常量不能是静态量，
		但是常量也可以和静态量一样没有实例也能访问

	属性
		和成员一样，不过后面大括号，里面set get 要么大括号，要么
		分号默认， get一定要return，set啥都不要
		set获得的值是叫value

		只有set或get就是只读只写属性

		自动实现
			不需要后备存储，直接set; get;

	构造函数
		普通的构造直接定义
		静态构造，static，没有其他修饰符，只能初始化静态变量，
		会在类实例所有之前完成运行

        对象初始化
        type xxx = new type() {xx=xx,xx=xx} 
            后面的发生在构造函数之后，只能访问public变量

        readonly
            这个和const不一样，const属于静态，readonly可以在运行时赋值一次
            只能在声明或者构造里初始化！

        this
            在实例方法，构造 属性索引中使用，引用到类级别的变量

        索引器
            returntype  this i[int index]{
             get ...
             set ...
             }  然后可以 obj[0] [1]  这样访问事先定下来的位置的值
             只能用于实例不能静态

             value作为set的传入参数值使用
             就是根据传入的值作为索引，然后自己定义set get什么东西

             可以重载，多个不同参数列表才行

             访问器（set get）可以内部有自己的public private
                但是必须是比外部的更严格的，而且只能有一个，不能两个都搞
                    必须是两个都存在的情况下才能

        partial class xxx
        partial void func();
        partial void func() {}
            部分类可以这样定义在不同文件，相同文件
            部分方法就是前面partial，必须void，而且隐式私有内部调用，
                第一部分声明，后面定义就行了

        继承
            class xxx ： xxx
            默认继承object，可以控制继承其他人

            屏蔽 (注意覆盖 屏蔽是不一样的）
                继承中如果数据的名字类型一样，屏蔽掉，
                函数签名一样可以屏蔽掉
                故意屏蔽使用new修饰符
                    new public string xxx;
                屏蔽之后的引用 base.xxx

                记住能访问到的才叫隐藏，不然不需要new的，比如base里的private
                    成员，覆盖它不用new，因为本来就访问不到

            使用基类引用强制转换，只会使用到基类的方法和域

            虚方法
                virtual xxxx 基类
                override xxxx 派生类， 这个是必须的，不然不管
                    然后就会调用到派生方法了

                方法属性索引都可以的
                但是override的必须是相同范围属性，同public或者。。
                    不能覆盖static

            继承的构造函数执行
                构造 : base(参数）
                构造 : this(参数） 这个是调用本类的其他某个构造
                    这种就可以让某个构造变成private

        类的限定符号
            public
            internal 这个只能在当前程序集引用，（目前不懂） 默认这个
            而使用using表示去掉一个限定符号，和程序集没关系

            成员的限定在类之内，不能超过的

        成员限定符号
            public 所有访问
            private 自己以及嵌套类访问
            protected 派生本身可访问
            internal 程序集分界，外部不可以，内部可以
            protected internal 两者的合体，是所有

        abstract 
            和virtual差不多，但是本身不能有实现，
            必须覆盖， 用override
            可以方法索引 属性 时间
            本身可以继承自其他类

        sealed class xxx
            不能作为基类的类

        staitc class 
            静态类

        扩展方法
            就是在类外想再加个函数，但是类本身不允许继承，不能修改，
            那就可以
            static class xxx {static method(this classtype xxx)}
                然后调用原来的class的实例就可以直接obj.method调用了
                必须静态！！(类，方法都是）

        命名方法
            camel 方式 局部变量和函数参数（第一个小写，后面首字母大写）
            私有变量和protected  _camle形式
            其他全首字符大写

    计算符号
        字面量，float xxxF
        U/u  ul/UL L/l 推荐l大写
        实数
            xxx.xxexx的形式
        字符用char 单引号
            char c4 = '\u005a'  unicode
            char c3 = '\x0061' 十六禁止ascii
        字面量字符串
            双引号 “   ” 常规里转换的
            @“”  字面上的，么有任何转换, 中间还能换行的！！

        bool 只能由关系比较产生，本身变量不具有bool意义

        比较，
            对于引用，只有引用同一个东西才会相等
            其他的是深度比较，也就是比较内容的
        && || !
        & ^ |   ~按位取反
        移位，有符号的因素右移注意

        定义用户类型的隐士转换
        public static implicit operator desttype ( sourcetype name)
            的形式定义一个函数就行了
            implicit 换成explicit的话就必须显式转换了 a = (desttype)b

        运算符重载
            必须public static returntype operator xxx （至少一个类参数）
               + - ! ~ ++ -- true false
               + - * / % & | ^ << >> == != < > <= >= 这些可以重载
                但是++ --没有前后置区别了

        typeof ()
            可以获得类型的信息，也是一个类，里面有每个域，方法，以及class的名字
            （用gettype方法获得）

        switch
            break 这个 必须，但是可以多个标签放一起，
                不然编译错误

        标签
            可以用来跳转到不同的位置，但是只能从标签当前或者更内层的作用域
            往外，
            switch里可以goto case xxx 或者 goto default

    using (type xxx = xxxx, xx = xx ) { 操作}
        对于实现了idisposable接口的类型可以这么做
        相当于python的with xxxx as xx
        会自动析构
        也可以 type xx =xx;
                using(xx)
                不过不太好
