Main 要大写
使用某个空间里的类，就在外面using xxxx；
自己也要放在一个空间里面

格式字符串
  {index, aligment:Cxx} 最后的表示输出格式，xx为需要的数字数量，具体各个不同，一般指的是小数点之后，
      没有的话就是general ， %g的形式
      e r p n x g f d c , r 表示保证parse方法转回数字和原来一样
      
///  文档注释
//  /* */ 普通注释

数据类型
schar char uint ushort ulong double float class interface delegate enum dynamic string object 最后三个是特殊类型
引用类型是实际存储堆中，一个引用在其他地方指向它

class
	包含字段，用于存储，默认有默认值
	方法 ，包含函数调用
	自动变量所有都不会自动初始化的

	访问修饰符
		private public  protected inernal (protected internal)

	默认权限：
		private，默认成员，方法都是私有的记住
		就是只能从当前类内部的函数访问
	名称嵌套
		本地变量是不能嵌套同名的，和类的字段倒是可以同名
	const 常量
		必须初始化，不能引用对象，因为编译而不是运行时要决定好值，
			只能null了
	传参
		ref 传引用 ，需要调用，声明函数的时候都用ref
		ref的话，一定要传入的是变量，不能是单单的计算式子或者值
		想要方法内部改变整个原先的引用，就要用到ref，不然
		只不过是复制了引用变量，

		输出参数
			out type var 声明
			out var 调用， 和ref一样都需要
			传入之后内部一定要先初始化，赋值，才能读取，
				外部直接放进去
		
		参数数组
			params type[] name 的形式
			type要自己定，必须是最后一个参数，内部只能同一个类型，
			必须只能有一个
			传入的时候，使用
				1，逗号间隔的一组值
				2，type[] arr = {}, 传入arr即可，
				注意不用修饰params
				注意空参数也是可以传给数组的，那样就是么有传入
				注意数组传的时候是复制当前值的
					除非是使用整个数组名传入的

			数组创建
				type[] name = new type[] {xxx};
		for each:
			foreach(type x in xxx)
				xxxxxx;

	方法重载
		同名，但是参数不同，返回值不算
	命名参数
		放在位置参数后面， var: val 的形式即可
	可选参数
		值类型可以 ， 引用，out param都不可以
		引用只能null的可以，
			可选参数的意思是可以附一个默认值记住，不是单单说
			可以省略，这样parmas也算了
		顺序：
			必选(包括命名）， 可选， params
			省略参数必须从尾部开始省略
				不然要用命名参数消除歧义

类
	成员声明 [特性】 【修饰符】 核心声明
		public static之类都是修饰符
	静态成员，	
		用类来引用，如果有表达式，会在初始化任何静态成员前计算
		必须用类名访问
	成员常量不能是静态量，
		但是常量也可以和静态量一样没有实例也能访问

	属性
		和成员一样，不过后面大括号，里面set get 要么大括号，要么
		分号默认， get一定要return，set啥都不要
		set获得的值是叫value

		只有set或get就是只读只写属性

		自动实现
			不需要后备存储，直接set; get;

	构造函数
		普通的构造直接定义
		静态构造，static，没有其他修饰符，只能初始化静态变量，
		会在类实例所有之前完成运行

        对象初始化
        type xxx = new type() {xx=xx,xx=xx} 
            后面的发生在构造函数之后，只能访问public变量

        readonly
            这个和const不一样，const属于静态，readonly可以在运行时赋值一次

        this
            在实例方法，构造 属性索引中使用，引用到类级别的变量

        索引器
            returntype  this i[int index]{
             get ...
             set ...
             }  然后可以 obj[0] [1]  这样访问事先定下来的位置的值
             只能用于实例不能静态

             value作为set的传入参数值使用
             就是根据传入的值作为索引，然后自己定义set get什么东西

             可以重载，多个不同参数列表才行

             访问器（set get）可以内部有自己的public private
                但是必须是比外部的更严格的，而且只能有一个，不能两个都搞
                    必须是两个都存在的情况下才能

        partial class xxx
        partial void func();
        partial void func() {}
            部分类可以这样定义在不同文件，相同文件
            部分方法就是前面partial，必须void，而且隐式私有内部调用，
                第一部分声明，后面定义就行了

        继承
            class xxx ： xxx
            默认继承object，可以控制继承其他人

            屏蔽
                继承中如果数据的名字类型一样，屏蔽掉，
                函数签名一样可以屏蔽掉
                故意屏蔽使用new修饰符
                    new public string xxx;
                屏蔽之后的引用 base.xxx
