其他：
    libc++是mac的
    libstdc++是gnu的，一般都是这个 ,在clang -stdlib=libc++ = libstdc++可以修改, 默认好像是gnu的
    共享名称
        使用设计模式共享名称，交流方便，
        库给了你方便的调用实现
        模式给了你组织函数调用的方法
        即使没有模式使用，也可以利用抽象封装继承多态，提前想到需要的部分预防
    针对接口而不是实现编程
    多用组合，少用继承
    把多变的部分抽离出来，保持耦合和复用性
    设计原则：
        对扩展开放，对修改关闭
        依赖倒置原则
            依赖抽象，而不是依赖实现


现象
    把易于变化的部分封装起来，作为一个单独的类，这样不用每次修改，每个子类继承的时候都重复修改了，直接复用变化部分的类的继承体系中的
    某个就行了. 行为也可以是某种类，因为行为也有状态，也有具体的动作 
    复用的类可以作为参数，可以直接在内部构造中用作初始化
    用虚函数用继承，不如使用这种额外类的方法,而且这样可以动态改变使用的组合类成员
tip：
    少用继承，多用组合
    继承要秉持is-a的关系注意，一般组合比较好而且可以动态修改

学名 策略模式 多种选择的模式
    把动态可改变的部分提取出来，作为算法族，组合起来
        使用java的名称，算法族中是实现关系，实现算法的抽象接口
        而类里面是继承关系，以及和算法是组合关系


现象
    需要在某件事情发生的时候执行一系列动作，还要保证动作的可扩展性
学名 观察者模式, 一对多模式通知模式
    主题就是观察对象，接受通知的就是观察者
做法：
    分为观察者以及主题，主题有公共的订阅，删除订阅和通知函数，利用抽象基类
                        观察者有公共的可被调用函数
                        把观察者注册到主题上，观察者本身留一个指针
                        这样观察者可以控制删除
                        同时可以在主题上留有接口和改变标记，让观察者主动去“拉”
    注意
        不要依赖观察者的顺序


现象：
    需要多种添加产品共通构造，而且添加需要动态，以后
    还会一直添加或删除
学名 装饰者模式
方法：
    首先是你的正常的基本物品的类继承体系，然后对于
        附加的点缀品，也从抽象基类继承出来一个抽象的点缀
        类，这个抽象的目的是提供后面具体装饰类可以
        进行多态调用的函数指针可用性的基础
    然后对于每个装饰类，包含一个基类指针，
        每个装饰类都可以在其他装饰的基础上进行动作了.
    注意针对抽象类编程
举例
    java中的inputstream类体系就是装饰器，利用装饰器在
    普通的派生类上包装一层功能
    注意给类加函数调用的时候，真真使用的类是
        装饰器里的成员的那个类，不是装饰器作为继承
        部分的那个类！！

现象：
    我需要在多个类似的对象中选择创建一个
学名 
    1 简单工厂方法 用于相同的创建流程给不同的类型
        使用一个对象把创建过程封装，返回具体的对象，
            使用基类指针引用，这样对接口编程，
            把变化缩小到最小
        工厂对象是固有唯一的，内部实现具体的创造某个类的对象
            的过程
    2 另一种工厂方法 用于不同的创建流程
        只提供一个create的接口，和具体的调用create的流程，
            由每个子类自己负责实现具体的创造流程
        这种就是由不同的工厂来创建不同的东西，而客户负责
        创建不同的工厂
指导原则
    不要使用具体类的引用，不要覆盖已有的方法，
        应该共享

定义：
    工厂方法模式把实例的创建推迟到了子类中
问题：
    如果参数传递失误，造成生产的对象会出错，
        可以使用类或者静态类型作为参数

现象：
    需要不同套件的一组部件，套件之间结构都一样，
方法： 抽象工厂模式
    这种可以把套件作为策略模式的部分传入，
    创建相关对象的家族，而不明确指定，使用抽象接口
        使用抽象的工厂对象
    工厂方法中使用的是方法接口,这里使用的是
        工厂接口
    抽象工厂中的每个方法都是工厂方法（抽象方法）

    两者区别：
        工厂方法通过继承来实现对象创建
        抽象工厂通过组合来作为另一个类的成员出现

现象：
    只能实现一个对象的类
方法：单件模式
    构造private，使用static方法和static变量构造和保存
        一个仅有的实例
    也可以直接在static变量里直接定义一个，这样的好处是
        运行时直接定义，不会受到多线程竞争的影响
        或者加入同步措施，保证检测和创建的那个代码
        只哟一人执行
    c++ 注意：
        对于静态类型变量，需要外部定义的方式至少进行一次
            声明,不然会报错的啊，说找不到变量

现象
    我有很多不同的基本类型，他们的具体执行接口都不一样，
        然后我需要通过一个通用的接口调用他们
方法 命令模式
    就是把具体的操作实现封装到一个命令里面，命令
    有一个接口execute函数，通用接口只需要接受这个命令
    对象作为参数，然后调用执行函数，具体的命令封装在里面
    一个动作对应一个命令
        对于为空的，定义一个空命令做兼容很重要
    好处还有可以打包一整块需要的命令一起执行
        以及队列中一次执行不想关的多个命令

现象
    需要实现适配一种实现，但是现有的接口都不对
方法：
    适配器
    将现有的类作为组成部分创建一个新类，利用现有类的接口功能组合完成新类的接口功能
    
    两种适配器  
        对象适配器 使用组合的方式
        类适配器  使用继承的方式
        外观模式  和适配器有点像，主要目的不是提供另外一套接口
                而是组合原来接口的复杂功能，提供简化的干净接口
            适配和外观都可以同时包装多个类的

    和装饰器的不同
        装饰器不会改变接口，可以无限叠加，适配器用来改变接口

    最少知识原则
        利用最少的知识接口 
        在某个类中，不要调用某个经过调用返回的对象的方法，这样就多了需要认知的类了，不好，
            直接返回那个类就行了

现象：
    集中不同的对象内部的调用方法拥有相同的模式
方法：
    模板方法模式 定义了一个算法步骤
    模板方法是一个固定不动的方法，内部的调用函数在不同的子类里有不同的实现，相同实现的共享base的方法
    hook: 制造可选流程
        在模板方法里放置一个条件选择，子类控制这个条件选择内函数的返货bool，来决定是否调用模板方法内部条件内部的
        方法
    好莱坞模式
        底层组件不要调用高层组件，让高层（抽象层也就是基类）去选择调用底层，这样没有具体实现的依赖

    区别：
        策略方法：使用参数获取某个派生类的行为，可互换
        模板方法：同一个接口，内部调用函数可以子类实现，可以基类实现, 模板提供算法步骤，
                由子类提供具体的某些内部调用的实现
                    框架类一般都是利用的模板方法，这样你可以覆盖实现内部的某些方法
                模板使用继承，策略使用组合
        工厂方法：子类决定怎样初始化实例

现象：
    需要对不同的结构的类进行遍历，不想重复代码
方法：
    实现迭代器
    在java里就是以前实现过的class内部的iteratorclass，利用这个iterator嵌套class返回你想要的

    一个类应该只有一个引起变化的原因,不要有多个，会复杂,要高内聚

    多个iterator时候。。。
        重复进行多个iterator的实现对于多个类迭代不好，可以再利用一个类把所有的类组合添加进去
            然后遍历那个类获得每个类，对每个类调用迭代器，这样可以动态添加新的类

    另一种迭代：
        树形迭代,如果需要遍历的项目中有另一个集合，也有普通的成员，可以让所有人继承同一套base，
            这个base里有两边各需要实现的部分函数，然后利用统一的遍历打印print函数，
            集合的print会递归print内部的成员，而成员的print只打印自己，
        使用外部迭代器（也就是需要用户手动next的，内部迭代器是只要用户一个call func，内部自动iter输出）
            利用stack，首先压入一个iterator，对于每个元素，都只打印自己，碰到组合元素，再
        这样就完全解耦合了
            缺点是每个品种多了不需要的函数
            优点是不需要额外判断每个类型再做函数决定了
