在所有单词中，把两个只相差一个字符的单词链接起来
    如果暴力，N^2会很大，
    方法，对于每个单词，在一个循环里把每个字符位置轮流设置 "_",
        然后加入到这个key代表的字典列表里面，这样只需要4n的处理时间，
        之后O(k^2)的时间来处理加入,比那个时间要少

宽度优先：
    这个主要是用来找无权重最短的距离的,利用队列，每次都是遍历距离最近的那些(每个使用过的点注意标记）
    这个的主要时间是O(V+E)因为每个点，每条边最多一次
深度优先：
    每次先把当前处理的放入栈，然后看时候还有需要处理的，如果有，继续递归
    每一个选项，如果全部结束后，发现不成功，就出栈，跳回上一层递归的状态，
    从那边的循环继续下一项
    加速方法：针对knight tour:
        每次找邻接节点开始的时候，针对这个节点，再找它的邻接，看它的邻接数量，按这个
        排序，第二邻接最少的那个最开始，这样更早遍历不常用节点，更容易早早达到全遍历
    普通的深度优先，就是遍历所有节点，正在遍历的，未遍历的，已遍历的，打上不同的标记，很快就完了
    O(V+E)

区别：
    深度广度的区别就在于对待当前节点的邻接节点时候，广度是加入队列，深度是立刻访问，
        而且深度在当前节点处理完后要去除当前节点的已访问状态（表明他已经不在当前节点的路上了，
            可以通过其他路径继续访问到他）

拓扑排序：
    利用深度优先建立每个节点的完成时间的记录，然后根据这个进行排序，
        完成时间最大的那个应该最先处理，也就是拓扑排序的首端：
            因为最大的那个就是深度中最靠近开头的，也就是最包含后面大部分的，
            所以应该在大部分之前处理

强联通分支：
    这个首先dfs，根据拓扑排序后，在反向图里按照这个排序的节点遍历，完成一组就是一个强分支

Djkstra:
    最短路径，利用优先队列，首先更新距离，除了出发点为0,其他都是无穷大，
    然后loop:
        取出最小点，更新周边点的距离，如果比之前设定的小的话，同时更新prev
    结束后就有了每个节点到出发点的最短路径了
    其实可以对出队列的数标记，就可以不用再次扫描了
    VlogV + ElogV  前者是从优先队列取出的时间，构造是O(V)平均的（本地构造）
                    后者是对每条边都会调用一个（可能）调整队列的变动距离的操作,所以是这样

prim:
    生成树算法：
        和最短路径一样，开始时候所有距离最大，开始点距离为0,
        每次从优先队列里取出最小距离的数，然后更新周围的仍然在队列里的数的距离，
            这里的距离指的是到出队列的数（也就是已经在生成树中的数）的最短距离，
            所以每次对新的出队列的数都更新一下自己的周围，下一个最小的就在这些或者
            原来的邻接数里面，反正最小的一定是邻接的，非邻接后续再更新，
