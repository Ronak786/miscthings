转换进制：
    这个有一个0的问题，这个可以用一个分支，如果当前number比base小，就模，否则递归，就可以处理了


hano tower, 分形三角形，迷宫问题都能利用递归解决
迷宫寻路：
    可以给每个走过的点标记，每次都是同样的4个方向，没有就从递归返回

动态规划：
    就是动态的根据接受而不是根据已有的设置记录来解决问题
    比如硬币问题，可以利用从1开始的构建，存下小硬币的最优方法，给大硬币用
        这个比递归好，因为递归会重复计算小硬币

hibert curve:
    有四个方向开口的形状，所有的大形状都是4个小形状构成的

两个桶互相倒的问题：
    每个步骤有6个动作full a, full b, move a to b, move b to a, drop b, drop a
    可以维护当前桶的状态，水量，今后的递归过程中不能再访问当前这种情况了，不然就无限递归了
    我认为，这个就是两个桶加减的问题，由于两个桶可以通过加减得到最大公约数，所以应该是所有
    最大公约的倍数直到两个数中最大的那个为止的所有都是可以的，其他不可以
       如果我们扩展定义成功为两个桶的水加起来成功也算，那么可以直到两个桶的总和那么多

    注意递归的缺陷，这个方法会导致溢出
    应该还有更简单的数学方法可以获得所有中间步骤，而且是最优结果，再思考下

两岸人食人族问题：
    这个需要两岸分别考虑，每次送船上的人单个双个等情况，一共两倍的情况，
        考虑过的全部放入已检验集合即可

表达式树的求值：
    postorder遍历，然后利用operator.add ... 来进行组合求值
