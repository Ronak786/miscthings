Note: 
	.pyc 平台无关的效率文件，如果源文件修改过这个会重新生成
	模块不会重复载入的
	python -m xxx  args  可以把标准路径下的模块当作脚本直接执行

	__name__ == "__main__" 
		这个在import的时候不成立，所有用来本地测试
	

module 相关函数
	dir() 显示内部名字 [n for n in dir(module) if not n.startswith('__')] 
		避免显示内部名字
	__all__ 这个变量在import的时候
		指示会自动import的变量，设置这个可以有效的屏蔽非强制导入一些无用之物
		from xx import * 只会导入__all__引入的变量
	__doc__
		这个文档字符串直接打出
	help() 
		这个比文档字符串更详细，还有函数标签
	官方网站找更详细的文档

	查找源代码：
		sys.path searching....
		use  module.__file__  !!!
		Note 模块像sys 融入了解释器，没有源码,或者是C写的

sys:
	sys.path  return a list of module place 模块查找位置
		you can sys.path.append(your path)
		一般放在site package里面
	PYTHONPATH  个人路径
	sys.argv 命令行参数 ,包括自己
	sys.exit(arg)  参数可选 推出程序 , 具体看pydoc解释参数
	sys.module 一个字典，模块名字到载入模块的位置的字典(目前导入的模块）
	sys.path  模块查找路径
	sys.platform 平台info
	sys.stdin/stdout/stderr  返回0 1 2 代表的文件

os:
	os.environ  环境变量的字典
	os.system('') bash命令
		os.startfile 这个在win中好用，因为路径有空格，这个可以处理，注意
			一般要使用r''防止python解释内部的一些东西
	os.sep  系统分隔符
	os.pathsep path变量中的分割
	os.linesep 行分割
	os.urandom(n) 返回随机数据

subprocess:
	拥有os.system   execve popen function

webbrowser
	webbrowser.open() 打开浏览器

fileinput:
	input(xxx) 参数可选，用于遍历 没有参数默认stdin，有参数'-'也是stdin
		inplace 表示本地修改，print的打印会导致当前行的改变
	filename()  return filename
	lineno() return line number  ,all-together
	filelineno   return line num of current file 
	isfirstline  first line of cur file
	isstdin  if cur is stdin
	nextfile() goto nextfile
	close     close all file
	close()
	
set:
	内建无需import
	无重复元素，
	可以使用list生成一个set
	set（range（10））
	operations:
		& | union issubset - ^ 等等
	set.union 静态方法，可以在reduce等函数里使用

	set只能包含不可变的值，如果要包含集合
		要set.add(frozenset(another-set))

heapq:
	不存在heap类型，利用list来做
	heap = []
	heappush(head, 1)
	heappop(head)
	heapify() 将任意list转成heap，上面的操作只能对heap做
	headreplace 放入一个，并且去掉最小的
	nlargest(n,iter)
	nsmallest(n,iter) 可以返回迭代对象中第n大小的元素，比普通的sort之后index更有效率

collections.deque:
	双向队列(单向可以用list表示）
	append,appendleft
	pop, popleft
	rotate(1,-1...)  轮转，默认右边
	extend, extendleft  这个会反向插入左边

time:
	time 包括年月日时分秒周几，年内第几天，夏令时开启与否
	asctime(tuple) turn tuple to stirng(default local cur time) 只负责转换，不管本地与否
	ctime(float) turn float from 1970 to string, to localtime == asctime(localtime()) 把
		秒数代表的国际时间转化为字符串的本地时间
	localtime() 把国际时间转换为本地元组，交给asctime专程string
	gmtime() 国际元组
	mktime 把本地tuple转换成国际秒
	sleep 
	strptime(把字符串转成本地元组）
	time.time() 转换成国际秒
	strftime 自定义
	localtime(seconds) turn to local time

datetime

timeit
	
random:
	random()  return real num [0,1)
	getrandbits(n) 返回n个随机比特的长整形值
	uniform 随机from a,b
	randrange(start ,stop,step) 返回这个范围内的随机数
	choice 选择list中一个
	shuffle 原地洗牌
	sample（seq, n)选择n个样本

re:
	正则表达式
	.  任意一个字符，必须一个，不能\n
	转义，由于\本身解释器认识，所以需要\\表示传给re的\,
		同时也可以使用r'xxx'
	匹配集合：
		[a-z] [^a-z]  特殊字符*.?+这些在字符集里不需要转义
		^这个如果需要匹配，且放在开头，需要转，否则不要
		-]放在开头不用转，-放在末尾也不用转，否则要转
	子模式和选择符号：
		(xx|yy) 匹配其中一个
	* 0~infi
	+ 1~infi
	? 0~1
	{m,n}  m~n
	^$  开头结尾
	function:
		compile(pattern) 创建内部匹配对象，更高效
		search(查找匹配 从任意地方
		match 从开头匹配
		split 切割 类似 string.split('') 但是这里匹配选择更广
			在匹配里如果有一个（xx）的括号匹配分组，那么这个匹配上去的也会当作分组出现
		findall 找到所有模式匹配的字符串
		sub(pattern, replace, string)
		escape 转义字符串中所有特殊字符 (方便避免本地解释）

	可以直接re.xxx() 调用，传入字符串pattern和文本
		也可以compile之后调用返回对象的相应函数

	成功：
		返回匹配对象，b = a.match(xxx), b.string  
		返回信息：
			匹配的分组：分组是按括号来制定的，最大的分组0,每个括号都是一个分组
	失败：
		返回None

shelve:(简易数据库，可以使用字典的方式访问）
	open("file",writeback=true) 后面这个可以保证修改是对文件的，
					否则如果访问，返回的永远是副本，修改也修改不会去
					比如 a['x'].append(6) 首先获取副本list，然后添加，元list不会被修改
			Note：writeback需要最后close！～～～

package:
	每个包都是一个目录，里面要有一个 __init__.py文件，
	当只导入这个包的时候，__init__.py文件内容就是包的内容！！！
	导入：
		tree:
		bin/
		├── gen.py
		├── inflist.py
		├── __init__.py
		import bin : 可以使用bin.xxx访问__init__中的内容
		import bin.gen  可以使用 bin.gen.xxx访问gen中的内容
		from bin import gen 可以使用gen.xxx访问gen中的内容


	

