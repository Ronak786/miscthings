inner:
    每个交易可以有多个输出，多个输入，要求是必须花掉所有的输入，重新分配，不能只标注一半，
    这样让每次的检验更加容易,只需要找到上一次交易，不需要跟踪所有交易

    具体的格式是2进制，表示成json的话，就是一个固定的meta头部，描述交易input output数量，hash等
        然后是每个input，自己的hash，对应的上个输出的hash以及ouput位置，
        然后是ouput，value以及pubkey
    
    script : 输出使用 256个
        将输入里的hash和这个脚本以及输出pubkey连接起来，如果能正确执行，说明交易无误
        OP_DUP 复制栈顶，压入
        OP_HASH160 对栈顶求hash
        OP_EQUALVERIFY  对栈顶两个求等式,同时消除他们
        OP_CHECKSIG 对剩下的验证签名,利用公钥对签名，得出原文的hash就对了
        这里每一个操作都是对当前栈顶的数据进行操作

    proof of burn:
        以少量币为代价，后面OP_RETURN，然后写入自己的任意信息，return
        前面的全部销毁 ，但你可以写入一些有用的信息,或者转入新币种

    pay to script:
        验证首先验证到一个script的hash，然后执行那个script，用于
        比较复杂的交易对象，这样不用直接由客户指定

    multisig:
        多方签名，这个可以用于三方认证，也就是第三方用于judge，
        这个钱一开始存于保管平台，任意两个人有权利决定钱的走向，
        正常交易，两人决定，出现分歧，第三方决定是同意哪一方，
        就和哪一方一起签另一个名的交易
        
        这个还可以用于微型交易，这个交易费较高，可以先付一个总的钱，multisig双方。
        然后单方面不断付钱，但是只在双方之间通信，不加入blockchain，最后一个交易
        会加入，那个是总体的，然后把未花掉的返还，这样就一个block了
        要加入也给locktime，算是超时，不然钱永远冻结了

    交易链：
        实际是用的就是hash链，每个链里面使用merkel tree，这样检验某个内部的
        块的有效性的时间是log的

bitcoin network:
    随时加入，没有退出，只要3小时联系不到你，就是退出了
    交易传播的过程，就是向自己的peer连接表的人发送交易信息，每个人
    接受后都会验证有效性，再查看是否重复，没有的话就会传播继续，否则停止

    未完全传遍网络导致的重复消费，某人发了两份，两个不同的节点接到不同的，由于每个节点都有重复
        检验，所以部分节点的内容不一致，这个不要紧，根据下次挖到数字的人决定哪个可以进入下一条链,
        要进6条才算完成交易的

    传递新块也是一样，每个节点检验的是新块的hash以及内部每个交易的hash，同时只接受最长链上的新块

    视频为止，大概20GB的区块链，
    full node :长期在线的node， 挖矿，拥有完整链，用于验证
    thin node : 基本只用于交易，只有部分链，和交易相关，相信full node的反馈

限定：
    一个块10min 挖出
    1M字节一个块
    20000签名一个块
    100M satoshis 每个bitcoin
    21M 总币数
    50 25 12 5 .。的新块奖励

    soft fork:
        新的版本出现的时候，推行到网上，只能作为更加严格的集合的有效操作，
        这样旧的可以仍然验证，但是无法操作新的部位，然后自己的块被拒绝，这样就会去更新
    hard fork:
        有些操作必须更新，不然无法验证，不能限定在旧的里面，这些需要hard fork硬推广
