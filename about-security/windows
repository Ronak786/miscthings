after win vista, ASLR
	use random load addresss for exe and dll and sys(driver)

hook:
	1
		setwindowshookex
		unhookwindowshookex
		需要模块instance，如果在模块内部，可以使用dlmain中获取instance
		在hook中return 1表示暂停hoook链，到此位置，截断消息，否则return Callnexthookex继续其他hook

	2
		openprocess -> virualallocex(create mem in target process) -> writeprocessmemory(write data into
				target process's mem) -> getproceaddress of loadlibrary(在所有系统中首次加载位置都是一样的，
					而系统启动的时候早就加载了，只需要映射，加载会随机取地址，映射都是一样的:w
					-> createremotethread(target_process,  func_pointer, param) .... 调用载入函数，
					最后就可以调用到dllmain，然后注入了

	3 
		appinit_dll -> your dll path
		loadappinit_dll = 1
		after reboot, will inject into every process by user32.dll

查找指定名字进程中的指定dll
	1 createtoolhelp32snapshot(th32cs_snapall, null) 
		process32first, process32next 来找到指定名字的process的pid
	2 createtoolhelp32snapshot(th32cs_snapmodule, pid) 
		process32first, process32next 来找到指定pid的所有模块的名字
	

mem alloc:
	globalalloc
	globallock
	globalunlock

找到指定pid的指定窗口
	enumwindows(proc, custom_data)
	in proc:
		getwindowthreadprocessid(hwind, &pid)
		if pid == custom_data's pid
			return false; // found, so return false
		else 
			return true; // continue search


消息：
	wm_dropfiles
		产生拖拽文件的消息，传入路径

dll:
	如果要自己制作只有dllmain又用的dll，需要一个dummy的dllexport函数，不然一个都没有，可能塞不进你需要的进程
