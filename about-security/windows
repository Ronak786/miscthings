after win vista, ASLR
	use random load addresss for exe and dll and sys(driver)

hook:
	1
		setwindowshookex
		unhookwindowshookex
		需要模块instance，如果在模块内部，可以使用dlmain中获取instance
		在hook中return 1表示暂停hoook链，到此位置，截断消息，否则return Callnexthookex继续其他hook

	2
		openprocess -> virualallocex(create mem in target process) -> writeprocessmemory(write data into
				target process's mem) -> getproceaddress of loadlibrary(在所有系统中首次加载位置都是一样的，
					而系统启动的时候早就加载了，只需要映射，加载会随机取地址，映射都是一样的:w
					-> createremotethread(target_process,  func_pointer, param) .... 调用载入函数，
					最后就可以调用到dllmain，然后注入了

	3 
		appinit_dll -> your dll path
		loadappinit_dll = 1
		after reboot, will inject into every process by user32.dll

普通code注入：
	1 C代码
		代码为threadfunc， data通过param传入，两者都要virtualallocex分配,前者可以通过把函数地址相减得到
		需要复制的大小，然后复制,最后也是通过createremotethread的方法执行的
		一般需要传入loadlibrary getprocaddress的地址，这个所有进程的都一样，
		注意：设置ollydbg的debug event的break on thread 可以在新县城执行的时候暂停
	2 汇编
		这个先在masm或者ollydbg中写好（可以写个简单C程序然后在ollydbg中打开然后手写）
		需要的硬编码数据可以是直接传入的，也可以是通过内部使用push的技巧传入栈（每次4字节，小端传）
		最后push esp就可以了,当作字符串地址

		传入字符串：
			1 直接push 到栈上，最后push esp即可传入字符串地址
			2 如果当前代码下面一个地址就是字符串，那么直接call 到接下来的代码处，就可以push入接下来的地址，
			同时跳到接下来要运行的地方实际去call真正的函数

api hook:
	劫持api的调用
	1 修改iat
	2 修改目标dll的eat
	3 注入dll的时候搜索修改call的地址
	4 利用debug的方法attach的时候修改int3， 收取break execption来修改

查找指定名字进程中的指定dll
	1 createtoolhelp32snapshot(th32cs_snapall, null) 
		process32first, process32next 来找到指定名字的process的pid
	2 createtoolhelp32snapshot(th32cs_snapmodule, pid) 
		process32first, process32next 来找到指定pid的所有模块的名字
	

mem alloc:
	globalalloc
	globallock
	globalunlock

找到指定pid的指定窗口
	enumwindows(proc, custom_data)
	in proc:
		getwindowthreadprocessid(hwind, &pid)
		if pid == custom_data's pid
			return false; // found, so return false
		else 
			return true; // continue search


消息：
	wm_dropfiles
		产生拖拽文件的消息，传入路径

dll:
	如果要自己制作只有dllmain又用的dll，需要一个dummy的dllexport函数，不然一个都没有，可能塞不进你需要的进程


debug
	debugactiveprocess  attach到pid的进程上调试
	waitfordebugevent   等待debug事件发生
	continuedebugevent 继续运行，用于停止后
		event:  1 oncreateprocessevent 通过createprocessdebuginfo  struct 可以
			获取process的信息
			readprocessmemory可以获取指定进程指定地址的信息，debug权限是可以的
			writeprocessmemory可以写入，这里写入0xcc 用来int3
				2 exceptiondebugevent 用来
					可以通过CONTEXT结构体 getthreadcontext()获取环境，这个里面可以有
						esp等等值, 然后你可以读写栈
				

