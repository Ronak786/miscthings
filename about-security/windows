after win vista, ASLR
	use random load addresss for exe and dll and sys(driver)

hook:
	1
		setwindowshookex
		unhookwindowshookex
		需要模块instance，如果在模块内部，可以使用dlmain中获取instance
		在hook中return 1表示暂停hoook链，到此位置，截断消息，否则return Callnexthookex继续其他hook

	2
		openprocess -> virualallocex(create mem in target process) -> writeprocessmemory(write data into
				target process's mem) -> getproceaddress of loadlibrary(在所有系统中首次加载位置都是一样的，
					而系统启动的时候早就加载了，只需要映射，加载会随机取地址，映射都是一样的:w
					-> createremotethread(target_process,  func_pointer, param) .... 调用载入函数，
					最后就可以调用到dllmain，然后注入了

	3 
		appinit_dll -> your dll path
		loadappinit_dll = 1
		after reboot, will inject into every process by user32.dll

普通code注入：
	1 C代码
		代码为threadfunc， data通过param传入，两者都要virtualallocex分配,前者可以通过把函数地址相减得到
		需要复制的大小，然后复制,最后也是通过createremotethread的方法执行的
		一般需要传入loadlibrary getprocaddress的地址，这个所有进程的都一样，
		注意：设置ollydbg的debug event的break on thread 可以在新县城执行的时候暂停
	2 汇编
		这个先在masm或者ollydbg中写好（可以写个简单C程序然后在ollydbg中打开然后手写）
		需要的硬编码数据可以是直接传入的，也可以是通过内部使用push的技巧传入栈（每次4字节，小端传）
		最后push esp就可以了,当作字符串地址

		传入字符串：
			1 直接push 到栈上，最后push esp即可传入字符串地址
			2 如果当前代码下面一个地址就是字符串，那么直接call 到接下来的代码处，就可以push入接下来的地址，
			同时跳到接下来要运行的地方实际去call真正的函数

api hook:
	劫持api的调用
	1 修改iat
		virtualprotect 修改的时候会用到，需要暂时更改iat所在段的那一块的属性，不然不能写
	2 修改目标dll的eat
	3 注入dll的时候搜索修改call的地址
	4 利用debug的方法attach的时候修改int3， 收取break execption来修改
	5 直接hook内部的call 指令，而不是iat表，先hook 修改原api开头为jmp新地址，然后call的时候恢复,
		然后调用元api，然后重新修改，然后返回
	6 5中的方法在每次调用的时候都要unhook然后调用原方法，但是在ntdll中一些方法前面有至少7字节的区域，
		其中5字节空，2字节作为调用头部但是没用，所以可以修改5字节为jmp指令到你的func，2字节为jmp到5字节的开头，
		这样就可以不用运行时修改了，只需要调用的时候注意多加两字节再调，
	7 对于短小的独立func，可以复制到用户区，然后修改原来地方为一个jmp，然后自由调用
	8 resumethread 这个比createprocess方便，这个在创建完后恢复运行的时候调用
		注意新线程内inject后要unhook，然后调用原来的resume，然后调用hook恢复resume的inject
		注意是在父亲里面createprocess系列函数内部调用的，这个还是父线程调用的哦

查找指定名字进程中的指定dll
	1 createtoolhelp32snapshot(th32cs_snapall, null) 
		process32first, process32next 来找到指定名字的process的pid
	2 createtoolhelp32snapshot(th32cs_snapmodule, pid) 
		process32first, process32next 来找到指定pid的所有模块的名字

会话：
	windows 6内核的系统vista 7 8 中系统进程在会话0， 每个用户一个会话，隔离他们，
		但是不能防止opeprocess virutalprotect等操作
		但是createremotethread不能再跨越会话了
		需要使用ntcreatethreadex 和zwcreatethreadex一样，然后选择不要suspend启动，
			因为如果这样，导致不同会话的不能启动恢复
	

mem alloc:
	globalalloc
	globallock
	globalunlock

找到指定pid的指定窗口
	enumwindows(proc, custom_data)
	in proc:
		getwindowthreadprocessid(hwind, &pid)
		if pid == custom_data's pid
			return false; // found, so return false
		else 
			return true; // continue search


消息：
	wm_dropfiles
		产生拖拽文件的消息，传入路径

dll:
	如果要自己制作只有dllmain又用的dll，需要一个dummy的dllexport函数，不然一个都没有，可能塞不进你需要的进程


debug
	debugactiveprocess  attach到pid的进程上调试
	waitfordebugevent   等待debug事件发生
	continuedebugevent 继续运行，用于停止后
		event:  1 oncreateprocessevent 通过createprocessdebuginfo  struct 可以
			获取process的信息
			readprocessmemory可以获取指定进程指定地址的信息，debug权限是可以的
			writeprocessmemory可以写入，这里写入0xcc 用来int3
				2 exceptiondebugevent 用来
					可以通过CONTEXT结构体 getthreadcontext()获取环境，这个里面可以有
						esp等等值, 然后你可以读写栈
				

api:
	getmodulehandle() 返回当前进程的基地值，可以找到pe头

隐藏进程
	进程获取createtoolhelp32snapshot, enumprocess -> 都是通过zwquerysysteminformation
	通过creattoolhelp32snapshot找到所有需要注入的进程，然后注入, 记住virtualproctec更改代码段的读写特性
		这个不能修改将来的创建的新进程
	2 通过createprocess内部的zwresumethread， 这个没有文档，会在新进程开始前运行，可以hook这个
		hook createprocess的时候就是调用原函数，然后利用返回的process handle进行loadlibrary操作即可


WOW64
	这个是64位系统下运行32位程序需要的一些组建，这个运行再用户太的，库名字和64位的一样，
	再getsytemdirectory(system32) shgetspecialfoldelpath(program_file(x86))的时候，wow64会截获请求
	把名字修改位返回system32 但实际上返回的是syswow64,这个是为了保持所有程序的一致性！！

	注册表的修改也是这样，不过有时候会共用，这个要注意

x64指令
	call 采用相对地址而不是绝对，目标= 当前 + 6（call长度） + 指令里的value

	传参rcx rdx r8 r9 或者 xmm0~3实数，不是用bp，所以传参使用mov而不是push
		但是栈上仍然会保留那段给4个参数的空间

aslr 随即地址
	这个可以通过cff explorer的修改功能修改 file header中的reloc stripped 为选中
		或者optional header中的dll character中的dll move为不选中，都可以取消aslr

	
tls:
	这个是会再线程和进程创建销毁的时候执行的函数，和dllmain的参数一样，可以注册多个，
	再optionsal direcotyr中的index 9中的指定地址

	利用ollydbg的break on systembreakpoint，然后在pe头里找地址，然后打断点，不然在ep停止，
	此时tls已经执行过了

	使用
		#pragme data_seg(".CRT$XLX")  
		PIMAGE_TLS_CALLBACK[] ={func1, func2, 0};
		#pragma data_seg() 
	即可
		
