selection : every time select from curpos to end the max and change with cur;
            so n exchanges and ~n^2 /2   compares , os O(n^2)
insertion: from the second, every time insert to left,
            need average  n^2 / 4 exchange and n^2 / 4 compare
            need worst  n^2 /2 exch and n^2 / 2 compare,

            if array is partial sorted ,insert is effective
            every time insert, it will cancel some inversions( inversions are
                (n, m) where m < n)
                so the exchange just the same as number of inversions
                and compare is one more than exchange every traverse 

            插入在实行时，最好时把数组往后挪，而不是每次都都交换

Shell: 
    在一个固定间隔上进行插入排序，然后间隔不断减少直到1，1 可以保证绝对排序，
    这样的原理是一次消除多个逆序对，而不是插入的一次一个
    间隔的选取，我们这里选择 1/2 ( 3^k -1), 这样也就是 x -> 3x + 1> 3(3x + 1) + 1 不断上升，
    然后最大取到N/3不到的值，这样往下递减做插入
    比较的上界是N*const * N^(2/3) 差不多， 不同的序列可以有不同的性能，
        更复杂的可以有40%的提高，
        有一个定理 h-sorted after, then k-sorted, still remain h-sorted,
        所以我觉得重叠的越少越好(也不一定）

merge sort:
    nlog(n) time, but use extra propotional to N's space
    a in-place merge is possible but complicated

    使用递推的方法来获取nlog n的复杂度，每次排序都是子序列的复杂度加上当前的一个合并动作
        （需要 n 或者至少n/2）这么多的合并比较

    优化合并：
        1 低于15个数使用插入 插入使用数组移动而不是交换
        2 合并前比较，如果前面最后一个和后面第一个满足大小关系，不合并
        3 两个数组交替使用，这个要有递归的思想，每次向下面的要求都是从要给传入另一个，规定好

    bottom-up merge:
        在同一个数组中，每次分别以1 2 4 8 个数为单位进行合并排序，其实和top down是一个性质的
        如果是2的幂次方的话，两者是一样的工作流程，如果不是的话，自底向上这个要快一点，因为
        最后多出来的数的比较被省去了
        自底向上适合对多个链表进行合并排序，这个时候需要掌控好链表头的位置，插入方便，

定理： 任何基于比较两个数的排序算法，都不能保证具有低于nlogn 的比较次数复杂度
证明：
        我们使用二叉树，因为基于比较则每次比较两个数，然后走向一个分支，
        最后会到达一个序列结果，因为n个数有n!阶乘个结果，所以树叶至少要有这么多个，
            否则会有序列无法得出正确结果，排序算法无效
        最坏比较次数就是树的高度，要保证这个高度不到nlogn 
        但是高为h的数最多有 2^h个叶子，那么就是要 n!要满足 < 2^h的h至少要满足这个条件，
        这样 h > log(n!)是一定要满足的， 后面根据斯特林公式 等价无穷大于nlogn,所以树的高度，
        也就是比较次数至少是nlogn

        合并基本比较次数最优，但是
            需要额外空间，如果对其他比如访问内存比较看重，可以有更好的方法，也可以不基于比较
