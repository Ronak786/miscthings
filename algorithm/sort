selection : every time select from curpos to end the max and change with cur;
            so n exchanges and ~n^2 /2   compares , os O(n^2)
insertion: from the second, every time insert to left,
            need average  n^2 / 4 exchange and n^2 / 4 compare
            need worst  n^2 /2 exch and n^2 / 2 compare,

            if array is partial sorted ,insert is effective
            every time insert, it will cancel some inversions( inversions are
                (n, m) where m < n)
                so the exchange just the same as number of inversions
                and compare is one more than exchange every traverse 

            插入在实行时，最好时把数组往后挪，而不是每次都都交换

Shell: 
    在一个固定间隔上进行插入排序，然后间隔不断减少直到1，1 可以保证绝对排序，
    这样的原理是一次消除多个逆序对，而不是插入的一次一个
    间隔的选取，我们这里选择 1/2 ( 3^k -1), 这样也就是 x -> 3x + 1> 3(3x + 1) + 1 不断上升，
    然后最大取到N/3不到的值，这样往下递减做插入
    比较的上界是N*const * N^(2/3) 差不多， 不同的序列可以有不同的性能，
        更复杂的可以有40%的提高，
        有一个定理 h-sorted after, then k-sorted, still remain h-sorted,
        所以我觉得重叠的越少越好(也不一定）

merge sort:
    nlog(n) time, but use extra propotional to N's space
    a in-place merge is possible but complicated

    使用递推的方法来获取nlog n的复杂度，每次排序都是子序列的复杂度加上当前的一个合并动作
        （需要 n 或者至少n/2）这么多的合并比较

    优化合并：
        1 低于15个数使用插入 插入使用数组移动而不是交换
        2 合并前比较，如果前面最后一个和后面第一个满足大小关系，不合并
        3 两个数组交替使用，这个要有递归的思想，每次向下面的要求都是从要给传入另一个，规定好
