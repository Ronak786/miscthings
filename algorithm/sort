切比雪夫不等式意义：
	实际的与平均数的差是标准差的倍数，在ｍ倍的范围内的概率是１－(1/m^2)
selection : every time select from curpos to end the max and change with cur;
            so n exchanges and ~n^2 /2   compares , os O(n^2)
insertion: from the second, every time insert to left,
            need average  n^2 / 4 exchange and n^2 / 4 compare
            need worst  n^2 /2 exch and n^2 / 2 compare,

            if array is partial sorted ,insert is effective
            every time insert, it will cancel some inversions( inversions are
                (n, m) where m < n)
                so the exchange just the same as number of inversions
                and compare is one more than exchange every traverse 

            插入在实行时，最好时把数组往后挪，而不是每次都都交换

Shell: 
    在一个固定间隔上进行插入排序，然后间隔不断减少直到1，1 可以保证绝对排序，
    这样的原理是一次消除多个逆序对，而不是插入的一次一个
    间隔的选取，我们这里选择 1/2 ( 3^k -1), 这样也就是 x -> 3x + 1> 3(3x + 1) + 1 不断上升，
    然后最大取到N/3不到的值，这样往下递减做插入
    比较的上界是N*const * N^(2/3) 差不多， 不同的序列可以有不同的性能，
        更复杂的可以有40%的提高，
        有一个定理 h-sorted after, then k-sorted, still remain h-sorted,
        所以我觉得重叠的越少越好(也不一定）

merge sort:
    nlog(n) time, but use extra propotional to N's space
    a in-place merge is possible but complicated

    使用递推的方法来获取nlog n的复杂度，每次排序都是子序列的复杂度加上当前的一个合并动作
        （需要 n 或者至少n/2）这么多的合并比较

    优化合并：
        1 低于15个数使用插入 插入使用数组移动而不是交换
        2 合并前比较，如果前面最后一个和后面第一个满足大小关系，不合并
        3 两个数组交替使用，这个要有递归的思想，每次向下面的要求都是从要给传入另一个，规定好
        4 在合并的时候，可以第二个部分逆向排序，这样可以少测试边界条件，第二部分向前，第一部分向后比较
            这个适合不是递归的自底向上版本

    bottom-up merge:
        在同一个数组中，每次分别以1 2 4 8 个数为单位进行合并排序，其实和top down是一个性质的
        如果是2的幂次方的话，两者是一样的工作流程，如果不是的话，有不同，自顶向下这个
            分下去的时候到底部会少些步骤，因为分布均匀，可以省略一些,而 自底向上对于最后一个
            多出来的部分可以一直不参与合并，直到最后,所以每层可以少合并一个大的,具体和2的倍数以及
            这个多余组处于合并两组的第一还是第二个有关。
        自底向上适合对多个链表进行合并排序，这个时候需要掌控好链表头的位置，插入方便，

        有一个变体：很适合链表，每次都是从头开始找两个有顺序的子链表，也就是某个元素比前面的小，就代表
            第二个链表的开始了

    计算逆序的方法：
        可以用nlogn， 就是在合并的时候，后面的插入前面的可以计算当前的逆序，然后重复每个分组就行了

定理： 任何基于比较两个数的排序算法，都不能保证具有低于nlogn 的比较次数复杂度
证明：
        我们使用二叉树，因为基于比较则每次比较两个数，然后走向一个分支，
        最后会到达一个序列结果，因为n个数有n!阶乘个结果，所以树叶至少要有这么多个，
            否则会有序列无法得出正确结果，排序算法无效
        最坏比较次数就是树的高度，要保证这个高度不到nlogn 
        但是高为h的数最多有 2^h个叶子，那么就是要 n!要满足 < 2^h的h至少要满足这个条件，
        这样 h > log(n!)是一定要满足的， 后面根据斯特林公式 等价无穷大于nlogn,所以树的高度，
        也就是比较次数至少是nlogn

        合并基本比较次数最优，但是
            需要额外空间，如果对其他比如访问内存比较看重，可以有更好的方法，也可以不基于比较

shell  AND merge:
        两个实际上差距并不是很大，在一个固定倍数的差距上,虽然shell目前还不是nlogn级别的，
            所以会显得略高

quick sort
    基本原理， 和合并相反，每次先选定一个数放在正确位置，然后区分左右子数组，各自递归继续
    边界条件可以通过在两边放置最大最小数来avoid 判断
    与选定数相同的数也要参与比较，因为如果不这样的话，在只有有限个不同数的情况下会出现平方复杂度
    要注意边界条件，以及保证每次循环至少一个（就是选定的数）在正确的位置上，这样递归就有穷了

    分析：
        利用递推，可以得出算法的平均复杂度（选的数的在每个位置是平均几率的）2nln(n)== 1.39nlog(n)
    使用随机打乱是为了在接下来的选数中不会总是选到边界数，这样会使性能变为平方

    据分析，选定数导致的单边比较次数的标准差是0.65N，根据切比雪夫不等式，偏离较远的概率十分小，
        可以忽略

	3-way qsort:
		这个是使用一个三分法，每次保证在[lo,lt-1]是小于所选数的 [lt,i-1]是等于所选数的 [i,gt]是正在进行判断的
		[gt+1]开始是大于当前数的，这样的方式可以在有相当数量相同数的时候具有较高的效率，总体上会比合并要高一点

		这个的分析需要用到香农熵，可以证明在没有重复数的时候是最坏情况，就是和普通ｑｓｏｒｔ一样，
		有重复元素的时候，这个算法可以达到最优


