symbol table:  这个就是字典，一个索引，一个值, 

利用无序链表实现：每次新元素比对后放在最前面，如果索引相同就更新
利用有序的数组实现, 使用插入排序的方法来插入元素，使用二分搜索的方法来查找元素
    技巧：如果二分搜索不到，最后返回low坐标，这个是恰好比要搜索的元素大的最小的那个，
        可以从这个地方开始往后移动的

    利用递推的方法，可以直到二分搜索最多使用lgN +1个比较
    可以使用qsort的方法，找到第n个最小的数，因为每次qsort可以保证一个数在自己的位置上，
        所以只要有第n个数在自己的位子就行了

二叉树:
    搜索，每次二分
    插入或替换，利用递归，需要返回当前节点，这样才能反映更改
    删除，如果只有一个或没有儿子，可以返回自己的另一个儿子
        如果有两个儿子，找到右子树中最小的，替换当前，

    非递归：
        插入需要两个指针，循环中，一个指向当前，一个指向儿子，然后根据儿子的状态
            判断是否更新儿子

    递归版的复杂度， 每次插入，搜索，都是2ln(n) 也就是1.39log n 和快排差不多

2-3树：
    就是每个节点最多两个key 可以有2个或3个儿子
    插入时的切换方法：（自底向上）
        只有一个key的节点，变成两个；
        有两个key的节点，中间那个放到parent里面去，parent同样判断
    操作复杂度： log(n) 到 log3底(n)， 后者为满3节点状态

    这种树不好实现，需要2 3 节点的转换，需要太多的消耗，所以我们使用一个变体：红黑树

红黑树：
    一个节点红色或黑色， 红色表示和父节点合起来表示2-3树中的一个3node节点，然后只允许
        左子树有红节点，不允许两个连续红节点，
        每次插入都会标记当前插入的节点为红色，然后递归变色，
        每次审查一个节点，有三种方式判断：
            如果右节点红，左转
            如果左节点红，它的左还是红，右转，
            如果两个节点都红，全部变黑，然后本人变红
            不断顺着递归回去向上

    2-3-4 tree:
        这种树的特点是每次插入的时候，每经过一个节点，如果那个节点当时是3key的，就分解成三个1 key的，
            所以到最底部一定会出现可以放进去的空位，（但是由于会分解，所以之前经过的上层会再次出现4key）

        实现方法，把红黑树中判断3key的情况移到递归前的开头（就是只改变原来的状态）

    红黑树中的删除:
        参照2-3-4树，首先找到那个要删除的节点，然后删掉它的右子树中最小的，把他换到这里来，
            删除方法：保证经过的每个节点至少有两个key，最后到最低左边，保证了至少两个，就可以
                删除最小的了（这样不会导致删掉后就一个都没了）， 然后递归网上，把4个的拆掉。
            然后交换到要删除的节点上，继续往上递归把4个的分解掉

        复杂度上 每个操作平均时间是1.00lgn -5  ，相当短
