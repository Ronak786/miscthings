symbol table:  这个就是字典，一个索引，一个值, 

利用无序链表实现：每次新元素比对后放在最前面，如果索引相同就更新
利用有序的数组实现, 使用插入排序的方法来插入元素，使用二分搜索的方法来查找元素
    技巧：如果二分搜索不到，最后返回low坐标，这个是恰好比要搜索的元素大的最小的那个，
        可以从这个地方开始往后移动的

    利用递推的方法，可以直到二分搜索最多使用lgN +1个比较
    可以使用qsort的方法，找到第n个最小的数，因为每次qsort可以保证一个数在自己的位置上，
        所以只要有第n个数在自己的位子就行了

二叉树:
    搜索，每次二分
    插入或替换，利用递归，需要返回当前节点，这样才能反映更改
    删除，如果只有一个或没有儿子，可以返回自己的另一个儿子
        如果有两个儿子，找到右子树中最小的，替换当前，

    非递归：
        插入需要两个指针，循环中，一个指向当前，一个指向儿子，然后根据儿子的状态
            判断是否更新儿子

    递归版的复杂度， 每次插入，搜索，都是2ln(n) 也就是1.39log n 和快排差不多

2-3树：
    就是每个节点最多两个key 可以有2个或3个儿子
    插入时的切换方法：（自底向上）
        只有一个key的节点，变成两个；
        有两个key的节点，中间那个放到parent里面去，parent同样判断
    操作复杂度： log(n) 到 log3底(n)， 后者为满3节点状态

    这种树不好实现，需要2 3 节点的转换，需要太多的消耗，所以我们使用一个变体：红黑树

红黑树：
    一个节点红色或黑色， 红色表示和父节点合起来表示2-3树中的一个3node节点，然后只允许
        左子树有红节点，不允许两个连续红节点，
        每次插入都会标记当前插入的节点为红色，然后递归变色，
        每次审查一个节点，有三种方式判断：
            如果右节点红，左转
            如果左节点红，它的左还是红，右转，
            如果两个节点都红，全部变黑，然后本人变红
            不断顺着递归回去向上
