select:
    O(1/2N^2) 每次选择当前之后最小的和当前进行交换，交换次数是最少的，因为每次交换
        都有一个数到了正确的位置 
insert:
    O(1/4N^2)交换 和 比较
    假设左边全序， 每个元素不断和前面的比较，直到找到大于等于前面的位置的时候位置
    大约是选择的2倍速度
部分有序：
    如果逆序对的数量是cN
    插入排序对这种的额效率是O(N),因为插入排序每次交换解决一个逆序对
shell sort:
    insert 效率低因为一次只交换一个逆序，
    shell每次交换多个逆序
    为什么要在内部使用inset来排序?
        1, 开始的时候stride大，所以排序元素数量少，这时候insert工作好，
        2， 后来stride小，但是是部分排序数组了，这时候insert工作也好
        stride大的逆序解决至少解决一对，就是交换的这两个数，
            除此之外，他们之间的数，因为前者大于后者,在他们之间的元素分成三类：
            比两者都小，都大，两者之间，前两种没影响，第三种减少了，
            所以shell排序被insert有效
        h-sort之后，g-sort, 然后一定仍然是h-sorteed, h>g
            这个不会证明，taopc 第三卷有

        选择的序列:
            3x+1, 或者 (9*4^i)-(9*2^i)+1  and 4^i-(3*2^i)+1的结合比较好

    具体方法：
        选择一个gap，从第一个位置开始到gap-1的所有数作为基准点，gap为间隔
            执行插入排序，然后gap缩小为下一个，直到gap为1
        (这个操作实际可以把每轮h的所有基准点的操作放在一起，
            只要从第一个h的地方开始，一直到结尾一直往后对每个数做向前的插入排序就行了，
            就好像同时在对多个间隔的序列进行插入排序)

shuffle sort:
    洗牌：目的是达到随机，
    方法：为每个数生成一个(0,1)浮点数，然后对他们排序即可, 这个保证均匀
    
    2, 首先排好序，然后从第一个数开始，每次在它前面产生随机数(包括它自己），然后交换他们两个
        这个保证每次当前牌之前的都是均匀洗过的，然后交换，就保证了，当前牌也参与到了均匀牌里面？？
    shuffle
    要注意， 如果总的情况数n，那么随机的seed表示数量要大于这个数，才能覆盖全部情况

convex hull:
    凸包
    Graham scan:
        从y轴最小的点开始，一定可以找到一个逆时针的凸包，所以找到所有其他点相对于它的
        角度，排序后，从最小的角度开始，每次转向，相对于上次转向，如果逆时针，就接受，继续，
        如果顺时针，就有问题，不是凸包，就放弃当前点，就像深度优先一样
    决定三点的顺逆关系：
        利用叉积，计算三角形面积的正负0

3-way-partition:
    利用O(N)次check 以及swap 排序一个只有三种类型元素的数组，
    方法是从左到右，碰到左类型的和左边head交换，碰到右类型的和tail交换，同时标记自加，但是
    检测下表不能加，换过来的数还要检测的。如果碰到中间的数，直接过，这样就O(N)了
