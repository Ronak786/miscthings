dfs 深度优先遍历，这个可以解决无向图的连接问题
bfs 广度优先，这个可以解决最短无权重路径问题

有向图：
	强联通分支，这个的寻找方法：
		首先利用后缀栈的遍历方法（就是名义上后缀，但最后是把当前元素入栈）
			找到逆向图的顺序，然后再按照那个顺序去遍历原始图，这样如果
			找到可以链接的，就是强联通的
		这个其实就是说从逆向的顺序来找，如果走顺了，说明顺逆都是可以的了走了，
			而点中的单向部分，逆向的时候，会因为逆向dfs的，所以会一开始被阻隔，
				选点的时候会因为栈的缘故先找后半边的。
				逆向单点的时候，会因为一开始就阻隔，所以也不会误判到不是强联通的点

最小生成树：
	这个用于找到联通图的最短的加权所有路径，方法是：
		找到一个点，对于这个点的每条边，加入一个小堆，找到当前所有在内的点所连的（内部不互相连）的边中最小的，
		作为声称树的一条边，一直找，知道任意两个点都会产生环位置（也就是两个点都在之前加入的里面）
