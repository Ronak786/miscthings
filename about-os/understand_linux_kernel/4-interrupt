interrupts: caused by outside device, mostly async
exception: caused by internal instrument executing, mostly sync

pic: programmable interrupt controller:
	8259a: each irq line connect one dev, when occurred interrupt,
		pic save line number in it, assert cput pin, then cpu can
		handle and know which number
		used for uniprocessor
	apic:
		local apic embeded in each smp cpu
		io apic connect to dev and on a bus to all local apic,
			io apic has a route table, 
			can staticly decide which cpu to send interrupt,
			or depend on process priority current running on 
			cpu the decide the lowest one to send, priority
			set by linux
			if same priority, use round-robin

	outer interrupt n ==> interrupt vector n+32 in idt table(each 8bytes)
	inner exception and nmi and fault use lower 32 numbers
		each exception has one handle for it

	cpu use IDT use handle all interrupts, int it , we have
		trap gate (for exceptions)
		interrupt gate( for interrupts)
	when interrupt happen:
		every instrument executed after, check interrupt and exception,
		if happened, search idt for gate, in idt is segment descriptor
		of gdt,  so search that,  and check priority

		if priority change happened, store and get another kernel stack
		from tss, save old one on new stack, 
		if it is a fault, save cs ip as the fault instrument so can 
		execute again,
		store cs ip flags on stack
		save error code
		run exception handler,

		restore cs ip eflags, return status of error code
		if priority change, restore stack
		check es fs gs  ds, if containe kernel segment, clear them
		for security issue

nest:
	interrupt can be nested, and should not block

initialize:
	int setup_irq() set up 256 of dummy irqs
	and in trap_init() set up specific for each exception, 
		outside interrupt are set in each driver
		set done by descriptor set in idt pointer to gdt's index
		int 8 (double fault) is special, not depend on stack which may be correupt,
			just jump to a special tss segment

exception handler:
	mostly push into stack error code and the do_handler_name() func and 
	call error_cmd func and call the handler, which mostly will just set correspongding 
	process's signal status, 
	when return ,ret_from_exception() , process run again and check signal pending and do with that
		this is immediately which different from interrupt which far from process

interrupt handling:
	io interrupt: device related
		share: every time interrupt come, search each func on same request line 
		dynamic alloc: every time only one dev attach onit ,but others can also do with it 
			when this dev detach

		only critical work and update of data struct should be done here, copy  issue should 
			in tasklet

		common procedure:
			save irq value and regs, send acknowledge to pic, run handler, terminate to ret_from_intr()

		interruptvectors:
			128 used to syscall tranditaionally, others >= 32 can assign arbitraly
			in linux ibm pc: interval timer be  irq0, slave pic be irq2
			0-19 nonamskable
			20-31 intel reserved
			32-127 external interrupt
			128 syscall
			128-238 external interrupt
			239 240 254 255 local apic related
			251-253 interprocessor interrut
			241-250 linux reserved

			how to get interrupt:
				1 by hardware jumper
				2 by some probe method
				3 by auto config bus such as pci

			init_IRQ() will set up interrupts dummyed in setup_idt()

			in irq_desc array, we have a irq_desc_t in each entry, 
				each corresponding to one interrupt line, have a handler for hardware ops(enable ,disable, ack, close..)
				and a list of software handler, and other status(inprogress, disable, pending), count, lock depth
			in irq_action:
				handler: routine 
				flag: shirq or, interrupt(shoud disable while handling)
				dev_id:private data
				irq: /proc/irq/num directory
				next: next link
				name

	timer interrupt: timer related
	interprocessor interrupt
