interrupts: caused by outside device, mostly async
exception: caused by internal instrument executing, mostly sync

pic: programmable interrupt controller:
	8259a: each irq line connect one dev, when occurred interrupt,
		pic save line number in it, assert cput pin, then cpu can
		handle and know which number
		used for uniprocessor
	apic:
		local apic embeded in each smp cpu
		io apic connect to dev and on a bus to all local apic,
			io apic has a route table, 
			can staticly decide which cpu to send interrupt,
			or depend on process priority current running on 
			cpu the decide the lowest one to send, priority
			set by linux
			if same priority, use round-robin

	outer interrupt n ==> interrupt vector n+32 in idt table(each 8bytes)
	inner exception and nmi and fault use lower 32 numbers
		each exception has one handle for it

	cpu use IDT use handle all interrupts, int it , we have
		trap gate (for exceptions)
		interrupt gate( for interrupts)
	when interrupt happen:
		every instrument executed after, check interrupt and exception,
		if happened, search idt for gate, in idt is segment descriptor
		of gdt,  so search that,  and check priority

		if priority change happened, store and get another kernel stack
		from tss, save old one on new stack, 
		if it is a fault, save cs ip as the fault instrument so can 
		execute again,
		store cs ip flags on stack
		save error code
		run exception handler,

		restore cs ip eflags, return status of error code
		if priority change, restore stack
		check es fs gs  ds, if containe kernel segment, clear them
		for security issue

nest:
	interrupt can be nested, and should not block

initialize:
	int setup_irq() set up 256 of dummy irqs
	and in trap_init() set up specific for each exception, 
		outside interrupt are set in each driver
		set done by descriptor set in idt pointer to gdt's index
		int 8 (double fault) is special, not depend on stack which may be correupt,
			just jump to a special tss segment

exception handler:
	mostly push into stack error code and the do_handler_name() func and 
	call error_cmd func and call the handler, which mostly will just set correspongding 
	process's signal status, 
	when return ,process run again and check signal pending and do with that
		this is immediately which different from interrupt which far from process
