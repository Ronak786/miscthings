get source , from git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
	then you can git pull to get the newest everytime

patch:   patch -p1 < ../xxxxx.patch

CONFIG_IKCONFIG_PROC to have /proc/config.gz
	use zcat to cat and redirect into file

about compile:
	use make > /dev/null to omit normal output
	use distcc  and ccache  and make -jn to imporve the efficiency of compile

c libs:
	use  self contrusted  c libs 

inline funcs:
	static inline XXX ,  safe  readability than  macros , 

inline assembly
	asm volatile(XXX)

likely and unlikely:
	help kernel to optimise

no mem protection
kernel stack  : 
	fixed size , not dynamically

sync and protection of race

process  fork  -> clone

every process has a process descriptor -- a structure
	in which we have a struct thread_info  , at fixed place of the descriptor
	in which we have a pointer of task_struct  ,we will refer to this frequently 
	the process descriptor is just under the kernel stack of each process
		and I think should be 8k alligned ( 64bit ， 4k when 32bit)

about process's status
	uninterruptible means :
		in sleep 
		the sleep can not be interrupted ; then can not be cancelled
		

we traverse by  next and prev of struct task_struct or the macro of process iterator

when creating , we use fork and exec when needed , we insist  copy on write , so only  the page table and a process descriptor
	needed to be created when fork , then all pages read only , before any write happens , that time , we alloc a new page

fork/vfork/_clone -> clone(pass in flags identifies which resoruce to share)  -> do_fork -> copy_process
	in copy_process :
		copy the process strcuct , 
		check not overflow the maxmum size of processes of the usef
		set condition to uninterruptible
		set flags internally
		set flags according to the clone() flags ( which resource to share)
		return to do_fork with address of new child
		then choose child to run first
		alloc pid for child
	



in vfork :
	we just fork but not copy even page addressed , parent wait child to exec or exit , accept a signal then continue 
		until that happens ,parent blocked , (differentiate from above by a special flag in clone's flag)



about threads:
	threads are just the same as processes , happen to share some resourceses
	use clone to  set seperate flags

about kernel-threads
	kernel-threads are processed only run in kernel space , can also be scheduled and preempted
	use kthread_create or kthread_run


about exit:
	set flag , release mm and fs statics ,save exit code
	notify parent , reparent children to group's other thread or the init
	change to zonbie status , 
	call schedule ( never return)

about wait
	detach from task list,notify if orphan , release all resources including thread_info and task list


about scheduler:
	we have real-time processes    and    normal processes ,   nornal one has  nice value , real-time has priority
		(nice value not 等差数列 )
	CFS  do with proportitions , when you have used little , then next time you require , you may be 
		sched to run immediately (if same priority) ,
	

how CFS works
	we have a scheduler run  when new process into runable status or blocked or periodically by the system timer , 

	update_curr:
		this func used to update time of a specific schedule entity( a task struct sometime),
			and the whole time of that cfs run queue
	
	enqueue_entity
	dequque_entity:
		used to manipulate red-black tree and the runnable  process queue. when block  exit  start or
			periodically

	in scheduler():
		pick next task -> pick next entity (now you get the next process to run)

switch from sleep and runnable:
	when wait or have lock, you sleep( mark sleep , add into wait queue , delete from rb tree )
	when  wake up , inverse
	
	we have interruptable and uninterruptable sleep , former will wake up when accept a signal


	prepare sleep:
		usually in a loop to avoid indefinite sleep(possibly), and deal with conditions to 
			wake up in the loop conditon or inner the loop
		add wait queue->prepare_to_wait -> loop {scheduler  check} -> finish_wait (the dequeue of
			current process is in schedule() ,in deactivate_task

	wake up:
		programs can call wake up themselves , -> try-to-wake-up -> activate_task(will enqueue task)
		but wake up not means ready to run ,so condition must be checked

	schedule:
		we set need_sched flag to signify kernel to schedule (  set when wake up or schedule_tick(when need
			preempt) , and flag will be checked when returning to user space or return from interrupt , 
			the flag is in per process thread info struct

	preemption:
		user-space-preemption:
			occur when return from interrupt context or kernel space , check need_sched is set , then call schedule()
		kernel-preemption:
			when return from interrupt handler , before into  kernel space(will check the preempt count)
			when preemp count == 0 , (during unlock , will call the check)
			if call schedule
			if a task in kernel block	

		(even in CFS we have time slice ,but it is  given by schedule , and every time schedule(
			when above environments ) that vruntime(timeslice) will add , and will choose the 
			least one to run (use red_black tree))
		
	
		

here comment:
	通常在一个函数或者一个循环的开头部分处理结束等特殊情况，然后才是正常的流程情况"


sched_rr  sched_fifo   sched_normal
	the latter one is nornal processes , use nice value ( in the same region of the priority value ,so 
		do not have meanings at the same time)
	the former two are real time schedulers , fifo  will run every real-time pros one after one ,
		until one give up the process(no preemption , except when higher priority real-time pro can
			preempt it)
		round-robin will run every  same priority real-time pro in a timeslice , but only when same
			priority, low ones can not preempt high ones( until all high ones over, low ones can
			run)
		
	until all real-time have blocked or exited , normals can run

note;
	nice and priority  use the same  region value but different values
	we have some funcs used to set and get real-time or nice values of processes(in LDK page 65)
		we can even set which cpus the process must run on and must not run on



