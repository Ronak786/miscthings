get source , from git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
	then you can git pull to get the newest everytime

patch:   patch -p1 < ../xxxxx.patch

CONFIG_IKCONFIG_PROC to have /proc/config.gz
	use zcat to cat and redirect into file

about compile:
	use make > /dev/null to omit normal output
	use distcc  and ccache  and make -jn to imporve the efficiency of compile

c libs:
	use  self contrusted  c libs 

inline funcs:
	static inline XXX ,  safe  readability than  macros , 

inline assembly
	asm volatile(XXX)

likely and unlikely:
	help kernel to optimise

no mem protection
kernel stack  : 
	fixed size , not dynamically

sync and protection of race

process  fork  -> clone

every process has a process descriptor -- a structure
	in which we have a struct thread_info  , at fixed place of the descriptor
	in which we have a pointer of task_struct  ,we will refer to this frequently 
	the process descriptor is just under the kernel stack of each process
		and I think should be 8k alligned ( 64bit ， 4k when 32bit)

about process's status
	uninterruptible means :
		in sleep 
		the sleep can not be interrupted ; then can not be cancelled
		

we traverse by  next and prev of struct task_struct or the macro of process iterator

when creating , we use fork and exec when needed , we insist  copy on write , so only  the page table and a process descriptor
	needed to be created when fork , then all pages read only , before any write happens , that time , we alloc a new page

fork/vfork/_clone -> clone(pass in flags identifies which resoruce to share)  -> do_fork -> copy_process
	in copy_process :
		copy the process strcuct , 
		check not overflow the maxmum size of processes of the usef
		set condition to uninterruptible
		set flags internally
		set flags according to the clone() flags ( which resource to share)
		return to do_fork with address of new child
		then choose child to run first
		alloc pid for child
	



in vfork :
	we just fork but not copy even page addressed , parent wait child to exec or exit , accept a signal then continue 
		until that happens ,parent blocked , (differentiate from above by a special flag in clone's flag)



about threads:
	threads are just the same as processes , happen to share some resourceses
	use clone to  set seperate flags

about kernel-threads
	kernel-threads are processed only run in kernel space , can also be scheduled and preempted
	use kthread_create or kthread_run


about exit:
	set flag , release mm and fs statics ,save exit code
	notify parent , reparent children to group's other thread or the init
	change to zonbie status , 
	call schedule ( never return)

about wait
	detach from task list,notify if orphan , release all resources including thread_info and task list


about scheduler:
	we have real-time processes    and    normal processes ,   nornal one has  nice value , real-time has priority
		(nice value not 等差数列 )
	CFS  do with proportitions , when you have used little , then next time you require , you may be 
		sched to run immediately (if same priority) ,
	
