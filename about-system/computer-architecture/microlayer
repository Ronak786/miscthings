微体系结构层一般不同的处理器不同，这里使用jvm虚拟机来介绍(仅整数处理部分）
数据通路：
	alu及其输入输出的总称
	一个时钟的下降沿开始驱动门电路，驱动总线获取输入，计算，结果开始转移到
	寄存器的输入处，然后在下一个上升沿载入寄存器，并停止寄存器输出，这样
	一轮数据通路就结束了(每一步都是有时延的，精心计算后，输出不会立刻变为另一边
	的输入的，可以防止数据串在一起)

	在我们的jvm里，读写内存使用特定的内存地址，数据寄存器，还有特殊的pc可以单字节
	读指令缓存，一般的读写只能以字（4字节）为单位，还能控制指令缓存中读出的内容
	的符号扩展，因为都出后是放在32位长寄存器的最低字节的,

	一般访问内存的指令，1周期：指令进入寄存器， 2周期：执行指令获取内存值
						3周期，值可以被接下来的指令从寄存器中拿出使用

指令执行的流程:(事先已经译码成微码了）
	在时钟下降沿开始一条微指令，上升沿开始结果的寄存器载入(包括上一条指令
		要求的内存操作的值，也在此时载入寄存器）下个指令的地址会在此时
		被计算放入微地址寄存器)，在下一个下降沿之前，
		当前指令的所有操作都会结束，并且下条微指令的位置会已经计算完成（根据上一条
		的位置以及计算结果中的一些位的影响，比如jn jz 和pc取到的内存的值）

		一般微地址寄存器直接就是一个送往控制器的信号，实现为虚拟寄存器

	栈：
		用来存储过程的局部变量，有一个基地址，一个栈顶寄存器，
		还可以用来保存计算的操作数，用push pop的方法来做算数运算，
		jvm是这样的
		jvm中内存分为常量 栈 方法 三个区，其中方法使用pc指向下一条指令，
			运算以字节为单位，其他的都是以字为单位的

		jvm中的函数调用的实现：
			压参数（包括一个0参数),这个0参数用来存放返回地址以及原来
			的基地址所存放的地址，在当前被调函数的局部变量空间的更上方，
			（栈是向上的），这个地方是放当前函数的其他执行变量的，
			返回后，返回值在原来的栈的上方,pc 基地址都在这是恢复

指令的汇编表示：
	对内存读写使用rd wr，对指令获取使用fetch
	指令被分解成一些固定的微指令执行码，这些
	都是简单的可以使用电路实现的操作

	微操作码的数值要和微地址一样，这样在取址的时候就知道现在这个
	是一个操作，而不是一个普通的数值(看书时注意每个内存操作
	都会有一个指令周期的延迟，到第三个微指令周期的时候时可以用的)

	在书中的指令的实现表里， 有的时有参数的，这种时候，就要
	再读一个指令部分（参数），但是注意这个不是指令，是这条指令

设计加速：
	缩短指令周期，缩短指令需要的周期数， 指令重叠执行（取址与执行独立同步进行）
	这些和价格，甚至性能都是矛盾的，
	合并一些操作
	添加总线一次获得多余一个寄存器操作数
	设置单独的取址单元，这样，取址，加pc就不需要占用一个周期的alu流程了
		还可以预先取后面的字节，不管是不是指令还是操作数，根据数据通路获取
		数据的状态决定下一步再怎么取

	fsm 有限状态机： 用来描述不同的动作对应的不同的回应操作（称之为进入了不同的状态
		而进行不同的动作）
	之后接下来要执行的指令，而当前指令的参数在上次读它的下一条指令
	之后由主循环读过了
