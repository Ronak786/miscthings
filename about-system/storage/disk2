带内 带外：
	指的是控制信号和数据走同一条线，或者不走同一条线

快照：
	这个实际上只复制属性和位图以及对应文件位图号的部分数据
		所以快，但是整个系统必须保证每次写入都写向新块，
		即使是修改元块，也要在新的地方写，不能覆盖旧数据，
		这样才能保证之后能恢复（只要重新定位文件标号就可以了）

		1 物理卷write direct 快照：
			这个会在快照之后，每次写入之前的原有部分会重定向到一个
			新的地方
		2 物理卷copy on write：
			这个会在快照之后第一次写入原有块的时候复制原有数据到新
			地方，然后旧地方可以用来存今后 修改的数据了

	CDP:
		连续保护数据，就是可以恢复到之前的任意时刻的状态：
			就是存储每一次的操作（必然如此，不然不可能恢复任意时刻)


IOPATH:
	第一步是；应用的缓存中复制到文件系统的缓存，这个可以不使用，直接跳过
			而进入下面的块层
		异步 同步io:
			异步可以让底层一次处理多个io，但是过多的话，导致缓存不足
			会强制转为同步（？？linux？？）， 
			如果使用文件系统缓存的话，可能会转为同步，这样可能高效一点

			如果挂载的时候选择async,那么所有使用的系统调用全部是异步的
				使用sync则全部是同步的？（那默认情况下呢），使用或
				不使用缓存的情况呢，有没有区别？

			dd一定用同步，因为不经过vfs，本身同步，所以底层一起同步

		网络文件系统：
			使用缓存的话，读会产生读过多的情况,读惩罚，毫无意义的加了一层，
				所谓惩罚，就是你发出一条io，但是系统地下需要多条io去实现
				在使用缓存，还远端系统的时候就是这样

				使用缓存，和远端的交流就会出现在page fault的时候了，
					而且每次都是4k，以页为单位进行，平白无故多了好多io
			底层仍然需要同样多的远程指令
			使用缓存的写会产生额外的读写操作，用来操作缓存的
				这个对于连续io的写入是有害的，只有满足缓存的区域特性的
				io才会有帮助
			使用write through的话，缓存会是一大阻碍，因为如果每次的io小于
				pageszie缓存大小，但是wt，则每次虽然只改了一小块，却要重复
				传输4k到远端，惩罚写很大


	direct io:
		使用这个会越过fs缓存，这样就要求应用的发送数据长度要是底层对应设备可接受
			的整数倍，不然一般设备会报错，要使用辅助分配dma整数倍空间的函数
