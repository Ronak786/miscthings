问题解决：
    当ping不通的时候，查看对应的网址ip，mask， 还有注意路由表是否有不对的项目，
        可以利用wireshark在不同的可路由网口查找，
        一般发包的时候比对机器上所有ip，属于的那个就会接受这个任务，但是路由表配置的优先级更高

    首先查看statistics-summary  平均流量
        statistics->service response time 响应时间
        analyze expert info 是否有异常的包

        注意发包无响应的时候可能的防火墙问题，或者nat转换ip的问题

    工具高级：
        tshark  -r 读取分析日志
        capinfos summary 信息
        service response time:
            tshark -n -q -r xxx.cap -z "rpc.programs' nfs
            tshark -n -q -r xxx.cap -z "smb.rtt'  cifs
            tshark -n -q -r xxx.cap -z "tcp.analysis.retransmission'/'out_of_order 重传, 乱序
            tshark -n -q -r xxx.cap -z "conv, tcp/udp/eth/ip ' 统计包里的对话

        editcap 切分大的dump包成小的，分割以时间间隔为限制

filter 
    host xxxx 可以指定对象的过滤
    注意nat的转换
    默认的seq number是相对值，所以从0开始，记住每次增长的是字节数，不是包数

    有两个filter， capture->options 里的capture filter是抓的时候的过滤，表示抓捕抓，
        界面上的filter是抓下来之后的过滤，这个更强大，
        可以 ip.addr eq xx && tcp.port eq xx
        可以使用协议名称 portmap || mount 协议过滤要考虑协议间的依赖，一起过滤
        可以单击包，右击选择follow tcp/udp stream
            可以在statistics => conversions 里查找
            可以在包右键找apply as filter 会自动生成过滤并应用，不然prepare as filter比较好
        save 之后可以可以再读取，利用wireshark
        analyze->expert info 
            简单的一些分析数据，包括冲传等
        statistics->service response time
                    summary
                    tcp stream graph

        ctrl-f 
            可以搜寻，选择为string就行了,如error

mtu:可以理解为frame里可以装载的data部分的最大大小，
    所以需要 握手的时候mss -20 -20 减去 ip tcp头部得到可以放入的数据，

注意wireshark里tcp的len不包含头部的，只有实际数据

tcp:握手：
    第三次用于防止请求包延迟严重后至的情况，这样即使请求最后到了，server的第二次确认加请求会被第三次确认可以被client否决
    一般tcp为防止分片，主动会分开给ip

mss：
    接受窗口 + 用赛窗口决定能发的字节数，mss决定一次性包里面的字节数，
    tcp里这个 < mtu -20 -20
65535
    这个是接受窗口原来的最大值，后来嫌小，就在option里加了一个2的指数，
        可以是win的值*2^指数得到最后的真的值，但是要wireshark捕捉到
        tcp握手才可能计算
        还有防火墙可能不识别，导致允许的带宽地下

congestion:
    慢启动：接受一个确认就加一个窗口宽度，总体是指数增长
    拥塞避免：到达一个临界窗口值的时候，开始每一轮ttl+1一个宽度
    rto  超时时间，有公式
        超时出现之后拥塞返回1mss，然后慢启动，直到之前未被确认的
        数量的一半那么多的时候为止，开始拥塞避免
        
        拥塞避免阶段出现快速重传：
            变为未确认数量的一半（临界窗口），拥塞窗口则+3Mss，,刚开始的临界窗口好像没有，
            默认应该是流量窗口的大小的某个倍数把
            继续拥塞避免，较快速恢复
        重传的策率：
         1 reno： 
            发一个，等ack，决定下一个发哪个，直到窟窿补完
          2 sack
                tcp选项里加入当前有窟窿的后面已经完成的部分的信息，
                发送方就知道接下来该补哪个了

    tip:
        没有拥塞的时候，接受窗口要越大越好，
        拥塞发生情况下，win小一点，可以避免拥塞用的
        rto 超时时间也很重要，对于不够tcp包数的传送，不会快速重传，
            延迟都在rto上
        sack  reno 有用

nagle
延迟确认：
    前者指发小包的时候前面未确认，后面先收集，等前面确认后一起发出
    后者指接受方接受后延迟固定（100ms比如）然后再发ack，这样可以减少网络拥堵，如果之间
    有其他包同样收到的话

拥塞算法：
    westwood 这个拥塞的时候根据当前丢包数量决定临界窗口减少程度,而不是i单单就减成一般
    vegas 这个是主动探测网络ttl的变化来主动调节，缺点是如果网络上有其他算法，会被压迫到效率差，
        如果都是他一个算法没问题


udp:
    这个不关心mtu，也不交换窗口大小，所以ip会分片
    丢包麻烦，需要全部冲传，而且分片如果其他人一直伪造morefragment flag的包，你就会无尽接受

cifs && nfs:
    都是通过不断的远程访问，
    每次获取一个信息点，比如文件属性之类的, 还有一些缓存，双控（双tcp链接）之类的功能cifs

dig +trace :
    强迫迭代查询，就是一定从root dns开始往下，而不是递归网上

    dns:
        非权威服务器可能有问题
        权威但是经过了缓冲投毒
        放大攻击， dig ANY xxx 然后修改源地址，返回的信息字节巨大3k， 可以用来攻击

ssl:
    这样之后https不会被是被，如果有密钥，可以导入使用，可以preference->protocol->ssl导入
