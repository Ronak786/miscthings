in additional to iscsi userspace, kernel module is most important

iscsi_init:
	iscsit_reg_transport():
		register the iscsit_tcp_transport struct
		check transport_list to see if already added
	alloc a dummy page
	memset a scatter struct for scatter gather
	make the page as the sg's using page

	create a mempool for command abort struct
	register a chrdev iscsi-scst-ctl with ctr_fops

	event_init():
		use netlink_kernel_create to create a netlink number of NETLINK_ISCSI_SCST
	create kmem cache for iscsi's session conn  thread_pool and command
	iscsi_register_target_template:
		register a iscsi_template struct(has add_target.. some actions)
		use scst_tgtt_sysfs_create() to add a kobj under targets entry
			add mgmt and some other attrs under it
		add into scst_template_list list
		set sysops in iscsi_conn_ktype.ops
	init a thread pool called iscsi_main_thread_pool and add into iscsi_thread_pools_list
	then for every cpu , create two  threads for read and write,so 8threads:
	read: istrd:
		test the mainthread's rd_list not emtpy:
		scst_do_job_rd:
			process_read_io:
	write:istrw:
		scst_do_job_wr:

	BUT THESE TWO READ WRITE LIST can not be tracked,tooooo long,
		so I think best way to track transport is tracking how every command
		I type to make iscst work calling  the module's function


AFTER INMOD scst_user  scst  
	we now have three list linking in dev_handler, devices scst_user_dev 
		when you use fileio_tgt to create a file dev, it will have:
			a devtype with operations to communicate with ioctl wait recv cmd in register in dev_handler;
			a scst_dev in devices 
			a scst_user_dev in dev_list manage dev's from fileio_tgt only(not important)
	now insmod iscsi_scst.ko,
		we have a iscsi entry in targets entry,this used to control adding and deleting targets:
			in it we have a mgmt which is set by scst_tgtt_sysfs_create():
		when  add_target iqn.2016-05.com.example:storage.iscsi-scst-1
		call scst_tgtt_mgmt_store:
			use scst_alloc_sysfs_work() to alloc a work calling scst_tgtt_mgmt_store_work_fn()
			add this work into sysfs_work_list ; wake up sysfs_work_waitQ
			create another sysfs_work_thread_fn in addition to scst's sysfs_work_thread_fn
				to avoid dead lock???(use onetime only as condition,so for every sysfs work
				we will have one sysfs thread)
			wait for that created work to be done and return
		
		in the work func scst_tgtt_mgmt_store_work_fn():
			scst_process_tgtt_mgmt_store:
				scst_check_grab_tgtt_ptr() check scst_tgt_template is in scst_template_list_entry
				(this is sure because we add it during init of iscsi_scst.ko)
				use scst_get_next_lexem() to get first string("add_target")
				call tgtt->add_target with target_name and subsequent opion strings
				iscsi_sysfs_add_target:
					iscsi_sysfs_send_event:
						check iscsi-scst-ctl's open state,should be open,
						(this is done by userspace iscsi_scstd process,so this should run)
						create a scst_sysfs_user_info struct (a info loader)
							check scst_sysfs_user_info_list to find a emtpy cookie as index
							add into scst_sysfs_user_info_list
						call event_send with E_ADD_TARGET as cmd code
						create a iscsi_kern_event struct event
						fill in desc infos(now no target and param info filled in ,just length)
							the cookie used to index the info struct and do wait completion
							 	at subcalls
						use __event_send():
							fill in netlink with your data and send with netlink_unicast()
						also send target name and params in subsequent two calls of __event_send
						scst_wait_info_completion() to wait for completion using info:
						then add target over
				HINT:		( here check  iscsi_scst file to see how netlink
							receive these commands and do what)
		AFTER USERSPACE get info and do some process, it will send a target command through ioctl
			into kernel,now we lookup this

		ioctl->add_target func:
			search in kernle's target_list(NOTE userspace have a targets_list,that is user's maintain)
			find the pre added user info: uinfo
			call __add_target(info) to the received kernel info:
				make sure target not already exist
				alloc a union add_info_union
				auto get an emtpy target id
				call iscsi_target_create() to create:
					alloc a iscsi_target struct,assign info's fields
					use scst_register_target() to alloc a scst_tgt field
						using iscsi_template as default actions
						search scst_tgt_template's tgt_list,should not exist
						add tgt into that template's list
NOTE: HEREH will create tgt which has operatons of the target,(attached into template )					
						in scst_tgt_sysfs_create():
							add that target under target iscsi under target entry
							create session, lun entry and mgmt(scst_luns_mgmt) under lun
							and other attrs
							scst_alloc_add_acg() to add scst_acg struct into tgt's acg list
				iscsi_add_attr() to add attrs from session keys and target keys
			back now, and complete ucmd->info_completion with err status from __add_target

					set scst_tgt's priv as target,
					add target into target_list
			NOW OVER: so add target from sysfs start from user's sysfs echo,then kernel's work
				and send command to user by netlink,then user do some process ,record
				into its own list, again using chrdev to send msg into kernel complete 
				the register( so the sysfs work and kernel user add target operations are
					sync for each other???)

