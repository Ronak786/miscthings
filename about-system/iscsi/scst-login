SHOULD ADD A TRACE_SCSI  tag !!!
login : is a very very long process
	login cmd, get some infos from reading , just like discovery session type is normal
		so  will create session in kernel, after that,
		now poll and receive write request,
		after written, because session_normal, begin create connection into kernel
			conn_pass_to_kern()
		after that, just close connection fd(now userspace connection closed)
		(NOTE in connection, when added in, together with socket, so now kernel
			can catch data from that sock and userspace can just close that sock
			because no use now)
		in connection add:
			alloc a conn adding into session's list,
			create a work which is a timeout( Nop-In interval 30): conn_nop_in_delayed_work_fn
				and schedule that time long,if wakeup but hang time not longer than that,
				again sleep rest time to fullfill that time long; if longer than that,
				and no nop cmd in list, send a nop command to initiator

	after adding conn,the conn_activate will add you to the iscsi rd thread list of thread istrd,
		which is an empty command, and do a read, got -EAGAIN just return;

	but now we have a scsi_data_ready in socket(may be above set nonblocking like options)
		now this func is called and we will got the struct iscsi_conn we set in sock struct
		and call the saved old data_ready func to fullfill normal net stack affairs
	after got scsi_data_ready return, we in process_read_io() and do_recv() get data,
		change into RX_CMD_START status and call cmnd_rx_start;
			(original is RX INIT => RX_CMD(-EAGAIN)(then get scsi_data_ready and again from here) => RX_CMD_START

		back into process_read_io, res == 0,so again add into list, now state is start so:
call link: process_read_io->cmnd_rx_start->scsi_cmd_start->scst_rx_command->scst_alloc_cmd(add in command's cbd from recv's head)
					(every command start with tag ISCSI_OP_SCSI_CMD)
NOTE :			(we now have a command head,not comand!!)
									->__scst_rx_cmd (get lun number)
							->scst_cmd_init_done->scst_init_cmd->__scst_init_cmd->
 scst_translate_lun(find scst_tgt_dev struct(using sess's list array and lun as index)
 	set cmnd's thread list == tgt's list == scst_dev's work list
	__scst_init_cmd()=>scst_pre_parse()->scst_get_cdb_info() get command info from scst_scsi_op_list(INQUERY)
	from scst_cmd_init_done->scst_process_active_cmd()(STATE_PARSE set in ini_cmd):

	scst_parse_cmd->then call scst_prepare_space()->then scst_preprocessing_done()
							(set request's state as ISCSI_CMD_STATE_AFTER_PREPROC,
							cmd's state SCST_CMD_STATE_PREPROCESSING_DONE_CALLED,
							return value as SCST_CMD_STATE_RES_CONT_NEXT,so out
							and return with state what will not continue in 
							scst_process_active_cmd)
	in scsi_cmd_start-> req->conn->transport->iscsit_receive_cmnd_data(req):cmnd_rx_continue:
		get direction and data len to receive and send
	INQUERY data size is zero,so set RX_END, res ==0 ,add into process_read_io list, again,now goto:
	cmnd_rx_end()-> iscsi_push_cmnd()->iscsi_cmnd_exec()->iscsi_restart_cmnd()-scst_process_redirect_cmd()
		(add into cmd's active list, this list I guess is scst_main_cmd_threads, so thread is 
		scst_cmd_thread)
	now return, to process_read_io, set in above processing, set state as init bhs, res == 0, so
		again do_recv, this time as start time,return again, can exit from istrd thread
		and kernel will wait for another data come to call iscsi_data_ready

	scst_cmd_thread:(got command from above processing)
		!list_empty(&p_cmd_threads->active_cmd_list):
			scst_process_active_cmd:
				scst_tgt_pre_exec->iscsi_pre_exec set cmnd->state SCST_CMD_STATE_EXEC_CHECK_SN
				scst_exec_check_sn->scst_exec_check_blocking->scst_do_local_exec()
									  ->scst_do_real_exec->dev_user_exec
												->scst_post_exec_sn
												__scst_cmd_put


NOTE: every command will allocate a struct , so can trace this ,another comnd will alloc
	another struct

	set TRACE ALL !!!

