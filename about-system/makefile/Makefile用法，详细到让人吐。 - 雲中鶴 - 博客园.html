<!DOCTYPE html>
<!-- saved from url=(0066)http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园</title>
<link type="text/css" rel="stylesheet" href="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/bundle-LessIsMore.css">
<link type="text/css" rel="stylesheet" href="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/64082.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/bundle-LessIsMore-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/aoyihuashao/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/aoyihuashao/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/aoyihuashao/wlwmanifest.xml">
<script async="" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/analytics.js"></script><script src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'aoyihuashao', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/blog-common.js" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<div id="home">
<div id="header">
	<div id="blogTitle">
		
<!--done-->
<div class="title"><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/aoyihuashao/">翔鹤岭</a></div>
<div class="subtitle">傲衣华少的技术博客</div>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li id="nav_myhome"><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/aoyihuashao/">首页</a></li>
<li id="nav_newpost"><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li id="nav_contact"><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E9%9B%B2%E4%B8%AD%E9%B6%B4">联系</a></li>
<li id="nav_rss"><a id="blog_nav_rss" class="menu" href="http://www.cnblogs.com/aoyihuashao/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="http://www.cnblogs.com/aoyihuashao/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li id="nav_admin"><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔-296&nbsp;
文章-11&nbsp;
评论-46&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html">Makefile用法，详细到让人吐。</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>0 Makefile概述 <br><br>-------------------------------------------------------------------------------- <br>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。 <br>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 <br><br>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 <br><br>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。 <br><br>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。 <br><br><br>0.1 关于程序的编译和链接 <br>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 <br>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 <br><br>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 <br><br>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File. <br><br>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。 <br><br>1 Makefile 介绍 <br><br>-------------------------------------------------------------------------------- <br>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 <br>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： <br><br>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 <br>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 <br>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。 <br>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 <br><br>1.1 Makefile的规则 <br>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。 <br>target ... : prerequisites ... <br>&nbsp; command <br>&nbsp; ... <br>&nbsp; ... <br>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 <br>prerequisites就是，要生成那个target所需要的文件或是目标。 <br><br>command也就是make需要执行的命令。（任意的Shell命令） <br><br>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。 <br><br>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：） <br><br>1.2 一个示例 <br>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。 <br>&nbsp; &nbsp; edit : main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o edit main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br><br>&nbsp; &nbsp; main.o : main.c defs.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c main.c <br>&nbsp; &nbsp; kbd.o : kbd.c defs.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c kbd.c <br>&nbsp; &nbsp; command.o : command.c defs.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c command.c <br>&nbsp; &nbsp; display.o : display.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c display.c <br>&nbsp; &nbsp; insert.o : insert.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c insert.c <br>&nbsp; &nbsp; search.o : search.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c search.c <br>&nbsp; &nbsp; files.o : files.c defs.h buffer.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c files.c <br>&nbsp; &nbsp; utils.o : utils.c defs.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c utils.c <br>&nbsp; &nbsp; clean : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm edit main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br>反斜杠（\）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。 <br>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 <br><br>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 <br><br>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 <br><br>1.3 make是如何工作的 <br>在默认的方式下，也就是我们只输入make命令。那么， <br><br>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 <br>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 <br>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 <br>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程） <br>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。 <br>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。 <br><br>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。 <br><br>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。 <br><br>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。 <br><br>1.4 makefile中使用变量 <br>在上面的例子中，先让我们看看edit的规则： <br>&nbsp; &nbsp; &nbsp; edit : main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o edit main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。 <br>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义： <br><br>&nbsp; &nbsp; objects = main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子： <br>&nbsp; &nbsp; objects = main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br><br>&nbsp; &nbsp; edit : $(objects) <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o edit $(objects) <br>&nbsp; &nbsp; main.o : main.c defs.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c main.c <br>&nbsp; &nbsp; kbd.o : kbd.c defs.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c kbd.c <br>&nbsp; &nbsp; command.o : command.c defs.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c command.c <br>&nbsp; &nbsp; display.o : display.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c display.c <br>&nbsp; &nbsp; insert.o : insert.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c insert.c <br>&nbsp; &nbsp; search.o : search.c defs.h buffer.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c search.c <br>&nbsp; &nbsp; files.o : files.c defs.h buffer.h command.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c files.c <br>&nbsp; &nbsp; utils.o : utils.c defs.h <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c utils.c <br>&nbsp; &nbsp; clean : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm edit $(objects) <br>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。 <br><br>关于变量更多的话题，我会在后续给你一一道来。 <br><br>1.5 让make自动推导 <br>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 <br>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。 <br><br>&nbsp; &nbsp; objects = main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br><br>&nbsp; &nbsp; edit : $(objects) <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o edit $(objects) <br><br>&nbsp; &nbsp; main.o : defs.h <br>&nbsp; &nbsp; kbd.o : defs.h command.h <br>&nbsp; &nbsp; command.o : defs.h command.h <br>&nbsp; &nbsp; display.o : defs.h buffer.h <br>&nbsp; &nbsp; insert.o : defs.h buffer.h <br>&nbsp; &nbsp; search.o : defs.h buffer.h <br>&nbsp; &nbsp; files.o : defs.h buffer.h command.h <br>&nbsp; &nbsp; utils.o : defs.h <br><br>&nbsp; &nbsp; .PHONY : clean <br>&nbsp; &nbsp; clean : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm edit $(objects) <br>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。 <br>关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。 <br><br>1.6 另类风格的makefile <br>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。 <br>&nbsp; &nbsp; objects = main.o kbd.o command.o display.o \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert.o search.o files.o utils.o <br><br>&nbsp; &nbsp; edit : $(objects) <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o edit $(objects) <br><br>&nbsp; &nbsp; $(objects) : defs.h <br>&nbsp; &nbsp; kbd.o command.o files.o : command.h <br>&nbsp; &nbsp; display.o insert.o search.o files.o : buffer.h <br><br>&nbsp; &nbsp; .PHONY : clean <br>&nbsp; &nbsp; clean : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm edit $(objects) <br>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。 <br>1.7 清空目标文件的规则 <br>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是： <br>&nbsp; &nbsp; &nbsp; &nbsp; clean: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm edit $(objects) <br>更为稳健的做法是： <br>&nbsp; &nbsp; &nbsp; &nbsp; .PHONY : clean <br>&nbsp; &nbsp; &nbsp; &nbsp; clean : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -rm edit $(objects) <br>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。 <br><br>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。 <br><br>2 Makefile 总述 <br>2.1 Makefile里有什么？ <br>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 <br><br>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 <br>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 <br>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 <br>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 <br>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。 <br>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 <br><br>2.2Makefile的文件名 <br>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 <br>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“--file”参数，如：make -f Make.Linux或make --file Make.AIX。 <br><br>2.3 引用其它的Makefile <br>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： <br>include &lt;filename&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符） <br>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句： <br><br>&nbsp; &nbsp; include foo.make *.mk $(bar) <br>等价于： <br>&nbsp; &nbsp; include foo.make a.mk b.mk c.mk e.mk f.mk <br>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： <br><br>如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。 <br>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。 <br>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如： <br><br>-include &lt;filename&gt;其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 <br>2.4 环境变量 MAKEFILES <br>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。 <br>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 <br><br>2.5 make的工作方式 <br>GNU的make工作时的执行步骤入下：（想来其它的make也是类似） <br><br>读入所有的Makefile。 <br>读入被include的其它Makefile。 <br>初始化文件中的变量。 <br>推导隐晦规则，并分析所有规则。 <br>为所有的目标文件创建依赖关系链。 <br>根据依赖关系，决定哪些目标要重新生成。 <br>执行生成命令。 <br>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 <br><br>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。 <br>3 Makefile书写规则 <br><br>-------------------------------------------------------------------------------- <br>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。 <br>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。 <br><br>好了，还是让我们来看一看如何书写规则。 <br><br>3.1 规则举例 <br>foo.o : foo.c defs.h&nbsp; &nbsp; &nbsp; # foo模块 <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -c -g foo.c <br>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事： <br><br>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。 <br>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件） <br><br>3.2 规则的语法 <br>&nbsp; &nbsp; &nbsp; targets : prerequisites <br>&nbsp; &nbsp; &nbsp; &nbsp; command <br>&nbsp; &nbsp; &nbsp; &nbsp; ... <br>或是这样： <br>&nbsp; &nbsp; &nbsp; targets : prerequisites ; command <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... <br>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。 <br>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上） <br><br>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。 <br><br>如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。 <br><br>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。 <br><br>3.3 在规则中使用通配符 <br>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。 <br><br>波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。 <br><br>通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\”，如“\*”来表示真实的“*”字符，而不是任意长度的字符串。 <br><br>好吧，还是先来看几个例子吧： <br><br>&nbsp; &nbsp; clean: <br>&nbsp; &nbsp; &nbsp; &nbsp; rm -f *.o <br>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。 <br>&nbsp; &nbsp; print: *.c <br>&nbsp; &nbsp; &nbsp; &nbsp; lpr -p $? <br>&nbsp; &nbsp; &nbsp; &nbsp; touch print <br>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。 <br>&nbsp; &nbsp; objects = *.o <br>上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样： <br>&nbsp; &nbsp; objects := $(wildcard *.o) <br>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。 <br>3.4 文件搜寻 <br>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。 <br><br>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 <br><br>&nbsp; &nbsp; VPATH = src:../headers <br>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方） <br>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种： <br><br>vpath &lt; pattern&gt; &lt; directories&gt; <br>为符合模式 &lt; pattern&gt;的文件指定搜索目录 &lt; directories&gt;。 <br>vpath &lt; pattern&gt; <br>清除符合模式 &lt; pattern&gt;的文件的搜索目录。 <br>vpath <br>清除所有已被设置好了的文件搜索目录。 <br>vapth使用方法中的 &lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。 &lt; pattern&gt;指定了要搜索的文件集，而 &lt; directories&gt;则指定了的文件集的搜索的目录。例如： <br><br>&nbsp; &nbsp; vpath %.h ../headers <br>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话） <br>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的 &lt; pattern&gt;，或是被重复了的 &lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如： <br><br>&nbsp; &nbsp; vpath %.c foo <br>&nbsp; &nbsp; vpath %&nbsp; blish <br>&nbsp; &nbsp; vpath %.c bar <br>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。 <br>&nbsp; &nbsp; vpath %.c foo:bar <br>&nbsp; &nbsp; vpath %&nbsp; blish <br>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="msgfont">3.5 伪目标 <br>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”， <br><br>&nbsp; &nbsp; clean: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm *.o temp <br>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标） <br>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。 <br><br>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 <br><br>&nbsp; &nbsp; .PHONY : clean <br>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写： <br>&nbsp; &nbsp; .PHONY: clean <br>&nbsp; &nbsp; clean: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm *.o temp <br>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性： <br>&nbsp; &nbsp; all : prog1 prog2 prog3 <br>&nbsp; &nbsp; .PHONY : all <br><br>&nbsp; &nbsp; prog1 : prog1.o utils.o <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o prog1 prog1.o utils.o <br><br>&nbsp; &nbsp; prog2 : prog2.o <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o prog2 prog2.o <br><br>&nbsp; &nbsp; prog3 : prog3.o sort.o utils.o <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cc -o prog3 prog3.o sort.o utils.o <br>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。 <br>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子： <br><br>&nbsp; &nbsp; .PHONY: cleanall cleanobj cleandiff <br><br>&nbsp; &nbsp; cleanall : cleanobj cleandiff <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm program <br><br>&nbsp; &nbsp; cleanobj : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm *.o <br><br>&nbsp; &nbsp; cleandiff : <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm *.diff <br>“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的 <br><br>3.6 多目标 <br>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。 <br><br>&nbsp; &nbsp; bigoutput littleoutput : text.g <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generate text.g -$(subst output,,$@) &gt; $@ <br>&nbsp; &nbsp; 上述规则等价于： <br><br>&nbsp; &nbsp; bigoutput : text.g <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generate text.g -big &gt; bigoutput <br>&nbsp; &nbsp; littleoutput : text.g <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generate text.g -little &gt; littleoutput <br>其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。 <br><br><br>3.7 静态模式 <br>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： <br><br>&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; <br>　　　 &lt;commands&gt; <br>...targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。 <br><br>target-parrtern是指明了targets的模式，也就是的目标集模式。 <br><br>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 <br><br>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 &lt;target-parrtern&gt;定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的 &lt;prereq-parrterns&gt;定义成“%.c”，意思是对 &lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取 &lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。 <br><br>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。 <br><br>看一个例子： <br><br>&nbsp; &nbsp; objects = foo.o bar.o <br><br>&nbsp; &nbsp; all: $(objects) <br><br>&nbsp; &nbsp; $(objects): %.o: %.c <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(CC) -c $(CFLAGS) $ &lt; -o $@ <br><br>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$ &lt;”和“$@”则是自动化变量，“$ &lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则： <br>&nbsp; &nbsp; foo.o : foo.c <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(CC) -c $(CFLAGS) foo.c -o foo.o <br>&nbsp; &nbsp; bar.o : bar.c <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(CC) -c $(CFLAGS) bar.c -o bar.o <br>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子： <br>&nbsp; &nbsp; files = foo.elc bar.o lose.o <br><br>&nbsp; &nbsp; $(filter %.o,$(files)): %.o: %.c <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(CC) -c $(CFLAGS) $ &lt; -o $@ <br>&nbsp; &nbsp; $(filter %.elc,$(files)): %.elc: %.el <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emacs -f batch-byte-compile $ &lt; <br>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。 <br><br>3.8 自动生成依赖性 <br>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include "defs.h"”，那么我们的依赖关系应该是： <br><br>&nbsp; &nbsp; main.o : main.c defs.h <br>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令： <br>&nbsp; &nbsp; cc -M main.c <br>其输出是： <br>&nbsp; &nbsp; main.o : main.c defs.h <br>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。 <br>gcc -M main.c的输出是： <br><br>&nbsp; &nbsp; main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/bits/sched.h /usr/include/libio.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/_G_config.h /usr/include/wchar.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/bits/wchar.h /usr/include/gconv.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \ <br>&nbsp; &nbsp; &nbsp; &nbsp; /usr/include/bits/stdio_lim.h <br><br>gcc -MM main.c的输出则是： <br>&nbsp; &nbsp; main.o: main.c defs.h <br>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。 <br>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。 <br><br>这里，我们给出了一个模式规则来产生[.d]文件： <br><br>&nbsp; &nbsp; %.d: %.c <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @set -e; rm -f $@; \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(CC) -M $(CPPFLAGS) $ &lt; &gt; $@.$$$$; \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \ <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm -f $@.$$$$ <br>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$ &lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。 <br><br>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： <br><br>&nbsp; &nbsp; main.o : main.c defs.h <br>转成： <br>&nbsp; &nbsp; main.o main.d : main.c defs.h <br>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如： <br>&nbsp; &nbsp; sources = foo.c bar.c <br><br>&nbsp; &nbsp; include $(sources:.c=.d) <br>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标 </div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>4 Makefile 书写命令 <br><br>-------------------------------------------------------------------------------- <br><br>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。 <br><br>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。 <br><br><br>4.1 显示命令 <br>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： <br><br>&nbsp; &nbsp; @echo 正在编译XXX模块...... <br>当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出： <br>&nbsp; &nbsp; echo 正在编译XXX模块...... <br>&nbsp; &nbsp; 正在编译XXX模块...... <br>如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 <br>而make参数“-s”或“--slient”则是全面禁止命令的显示。 <br><br><br>4.2 命令执行 <br>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如： <br><br>&nbsp; &nbsp; 示例一： <br>&nbsp; &nbsp; &nbsp; &nbsp; exec: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd /home/hchen <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwd <br><br>&nbsp; &nbsp; 示例二： <br>&nbsp; &nbsp; &nbsp; &nbsp; exec: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd /home/hchen; pwd <br>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。 <br><br>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。 <br><br><br>4.3 命令出错 <br>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。 <br><br>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。 <br><br>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： <br><br>&nbsp; clean: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -rm -f *.o <br>还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。 <br>还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。 <br><br>4.4 嵌套执行make <br>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。 <br><br>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： <br><br>&nbsp; &nbsp; subsystem: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd subdir &amp;&amp; $(MAKE) <br><br>其等价于： <br><br>&nbsp; &nbsp; subsystem: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(MAKE) -C subdir <br>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。 <br><br>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。 <br><br>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明： <br>export &lt;variable ...&gt; <br>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明： <br>unexport &lt;variable ...&gt; <br>如： <br>&nbsp; &nbsp; <br>&nbsp; &nbsp; 示例一： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; export variable = value <br><br>&nbsp; &nbsp; &nbsp; &nbsp; 其等价于： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; variable = value <br>&nbsp; &nbsp; &nbsp; &nbsp; export variable <br><br>&nbsp; &nbsp; &nbsp; &nbsp; 其等价于： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; export variable := value <br><br>&nbsp; &nbsp; &nbsp; &nbsp; 其等价于： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; variable := value <br>&nbsp; &nbsp; &nbsp; &nbsp; export variable <br><br>&nbsp; &nbsp; 示例二： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; export variable += value <br><br>&nbsp; &nbsp; &nbsp; &nbsp; 其等价于： <br><br>&nbsp; &nbsp; &nbsp; &nbsp; variable += value <br>&nbsp; &nbsp; &nbsp; &nbsp; export variable <br>&nbsp; &nbsp; <br>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。 <br><br>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。 <br><br>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来： <br>&nbsp; &nbsp; <br>&nbsp; &nbsp; subsystem: <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= <br>&nbsp; &nbsp; <br>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。 <br><br>还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到： <br>&nbsp; &nbsp; <br>&nbsp; &nbsp; make: Entering directory `/home/hchen/gnu/make'. <br>&nbsp; &nbsp; <br>而在完成下层make后离开目录时，我们会看到： <br>&nbsp; &nbsp; <br>&nbsp; &nbsp; make: Leaving directory `/home/hchen/gnu/make' <br><br>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。 <br>---++++4.5 定义命令包 <br><br>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如： <br>&nbsp; &nbsp; define run-yacc <br>&nbsp; &nbsp; yacc $(firstword $^) <br>&nbsp; &nbsp; mv y.tab.c $@ <br>&nbsp; &nbsp; endef <br><br>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。 <br>&nbsp; &nbsp; foo.c : foo.y <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(run-yacc) <br><br>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。 <br><br><!--End_rbody_48887978//--></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(1650865,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;ee2d70d4-14e6-de11-ba8f-001cf0cd104b&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/aoyihuashao/" target="_blank"><img src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/u103257.jpg" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/aoyihuashao/">雲中鶴</a><br>
            <a href="http://home.cnblogs.com/u/aoyihuashao/followees">关注 - 0</a><br>
            <a href="http://home.cnblogs.com/u/aoyihuashao/followers">粉丝 - 21</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;ee2d70d4-14e6-de11-ba8f-001cf0cd104b&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(1650865,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">4</span>
    </div>
    <div class="buryit" onclick="votePost(1650865,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650747.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650747.html" title="发布于2010-01-18 15:02">SQL设置数据库属性(不区分大小写，重音，假名，宽度)</a><br><a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/19/1651434.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/19/1651434.html" title="发布于2010-01-19 13:17">VC 遍历窗口所有子控件。</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2010-01-18 17:16</span> <a href="http://www.cnblogs.com/aoyihuashao/">雲中鶴</a> 阅读(<span id="post_view_count">8982</span>) 评论(<span id="post_comment_count">0</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=1650865" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html#" onclick="AddToWz(1650865);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=64082,cb_entryId=1650865,cb_blogApp=currentBlogApp,cb_blogUserGuid='ee2d70d4-14e6-de11-ba8f-001cf0cd104b',cb_entryCreatedDate='2010/1/18 17:16:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank">【推荐】超50万VC++源码: 大型组态工控、电力仿真CAD与GIS源码库！</a><br><a href="http://click.aliyun.com/m/43774/" target="_blank">【缅怀】传奇谢幕，回顾霍金76载传奇人生</a><br><a href="http://arction.cn/" target="_blank">【推荐】业界最快速.NET数据可视化图表组件</a><br><a href="https://buy.cloud.tencent.com/domain?fromSource=gwzcw.882687.882687.882687" target="_blank">【腾讯云】买域名送解析+SSL证书+建站</a><br><a href="https://www.yunqi2050.com/#/index" target="_blank">【活动】2050 科技公益大会 - 年青人因科技而团聚</a><br></div>
<div id="opt_under_post"></div>
<div id="cnblogs_c1" class="c_ad_block"><a onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;C1&#39;);" href="https://cloud.tencent.com/solution/la?fromSource=gwzcw.883654.883654.883654" target="_blank"><img width="300" height="250" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/24442-20180326113514896-610961046.jpg" alt="腾讯云0326"></a></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="https://news.cnblogs.com/n/592754/" target="_blank">IAC集团董事长：比尔·盖茨的情商只有蜗牛那么大</a><br> ·  <a href="https://news.cnblogs.com/n/592753/" target="_blank">360公司COO陈杰退休 已淡出近半年时间</a><br> ·  <a href="https://news.cnblogs.com/n/592752/" target="_blank">腾讯云在香港增开第二个数据中心，助力云上粤港澳大湾区建设</a><br> ·  <a href="https://news.cnblogs.com/n/592751/" target="_blank">华米第四季度净利润1110万美元 同比增长68.2%</a><br> ·  <a href="https://news.cnblogs.com/n/592750/" target="_blank">Uber网约车帝国瓦解：印度市场被指注定失败</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="cnblogs_c2" class="c_ad_block"><a onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;C2&#39;);" href="http://click.aliyun.com/m/42835/" target="_blank"><img width="468" height="60" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/TB1mEZFaWmWBuNjy1XaXXXCbXXa-468-60.jpg" alt="阿里云0308"></a></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/575255/" target="_blank">写给自学者的入门指南</a><br> ·  <a href="http://kb.cnblogs.com/page/578690/" target="_blank">和程序员谈恋爱</a><br> ·  <a href="http://kb.cnblogs.com/page/585734/" target="_blank">学会学习</a><br> ·  <a href="http://kb.cnblogs.com/page/588938/" target="_blank">优秀技术人的管理陷阱</a><br> ·  <a href="http://kb.cnblogs.com/page/590141/" target="_blank">作为一个程序员，数学对你到底有多重要</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><p align="center">
</p><div align="center"><img height="100" alt="" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/r_2_aoyihuashao.jpg" width="100" border="0"></div>
<p align="center"><a onclick="var tempSrc=&#39;http://sighttp.qq.com/wpa.js?rantime=&#39;+Math.random()

+&#39;&amp;sigkey=7449126a369fb26b243b99fb5080e18053516e4d69c8fcae55b12d7e9e1e3ff0346ba2d1a2b66b03d17fb0ca68431a9a&#39;;var 

oldscript=document.getElementById(&#39;testJs&#39;);var newscript=document.createElement(&#39;script&#39;);newscript.setAttribute

(&#39;type&#39;,&#39;text/javascript&#39;); newscript.setAttribute(&#39;id&#39;, &#39;testJs&#39;);newscript.setAttribute(&#39;src&#39;,tempSrc);if(oldscript == 

null){document.body.appendChild(newscript);}else{oldscript.parentNode.replaceChild(newscript, oldscript);}return false;" href="http://sighttp.qq.com/cgi-bin/check?sigkey=7449126a369fb26b243b99fb5080e18053516e4d69c8fcae55b12d7e9e1e3ff0346ba2d1a2b66b03d17fb0ca68431a9a" target="_blank" ;=""></a></p>
<p align="center"><img alt="翔鹤岭访问次数" hspace="4" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/index.php" align="center" vspace="2" border="0"></p>
<p align="center"><a onclick="var tempSrc=&#39;http://sighttp.qq.com/wpa.js?rantime=&#39;+Math.random()

+&#39;&amp;sigkey=7449126a369fb26b243b99fb5080e18053516e4d69c8fcae55b12d7e9e1e3ff0346ba2d1a2b66b03d17fb0ca68431a9a&#39;;var 

oldscript=document.getElementById(&#39;testJs&#39;);var newscript=document.createElement(&#39;script&#39;);newscript.setAttribute

(&#39;type&#39;,&#39;text/javascript&#39;); newscript.setAttribute(&#39;id&#39;, &#39;testJs&#39;);newscript.setAttribute(&#39;src&#39;,tempSrc);if(oldscript == 

null){document.body.appendChild(newscript);}else{oldscript.parentNode.replaceChild(newscript, oldscript);}return false;" href="http://sighttp.qq.com/cgi-bin/check?sigkey=7449126a369fb26b243b99fb5080e18053516e4d69c8fcae55b12d7e9e1e3ff0346ba2d1a2b66b03d17fb0ca68431a9a" target="_blank" ;=""><img alt=" " src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/pa" border="0"></a>&nbsp;</p><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/aoyihuashao/">雲中鶴</a><br>园龄：<a href="https://home.cnblogs.com/u/aoyihuashao/" title="入园时间：2009-12-11">8年3个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/aoyihuashao/followers/">21</a><br>关注：<a href="https://home.cnblogs.com/u/aoyihuashao/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;ee2d70d4-14e6-de11-ba8f-001cf0cd104b&#39;)">+加关注</a></div><script>getFollowStatus('ee2d70d4-14e6-de11-ba8f-001cf0cd104b')</script></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<div class="catListLink">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/aoyihuashao/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
<div class="catListPostCategory">
<h3 class="catListTitle">随笔分类<span style="font-size:11px;font-weight:normal">(195)</span></h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/aoyihuashao/category/231011.html">【1】C/C++(34)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/aoyihuashao/category/411660.html">【1】Linux/shell(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/aoyihuashao/category/289404.html">【1】QT(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/aoyihuashao/category/223380.html">【1】VC数据类型(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/aoyihuashao/category/241637.html">【1】界面-绘图(27)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/aoyihuashao/category/289631.html">【2】ORACLE(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/aoyihuashao/category/223370.html">【2】SQLSERVER(34)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/aoyihuashao/category/244499.html">【3】汇编(1)</a> </li>

<li><a id="CatList_LinkList_0_Link_8" href="http://www.cnblogs.com/aoyihuashao/category/223443.html">【4】网页类(5)</a> </li>

<li><a id="CatList_LinkList_0_Link_9" href="http://www.cnblogs.com/aoyihuashao/category/223444.html">【5】纯算法(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_10" href="http://www.cnblogs.com/aoyihuashao/category/223465.html">【a】Mobile6(5)</a> </li>

<li><a id="CatList_LinkList_0_Link_11" href="http://www.cnblogs.com/aoyihuashao/category/223442.html">【b】电脑应用(10)</a> </li>

<li><a id="CatList_LinkList_0_Link_12" href="http://www.cnblogs.com/aoyihuashao/category/227698.html">【c】网址收藏(7)</a> </li>

<li><a id="CatList_LinkList_0_Link_13" href="http://www.cnblogs.com/aoyihuashao/category/223469.html">【v】网摘趣闻(17)</a> </li>

<li><a id="CatList_LinkList_0_Link_14" href="http://www.cnblogs.com/aoyihuashao/category/223385.html">【z】传奇服务器(5)</a> </li>

<li><a id="CatList_LinkList_0_Link_15" href="http://www.cnblogs.com/aoyihuashao/category/421996.html">【z】书籍文章</a> </li>

<li><a id="CatList_LinkList_0_Link_16" href="http://www.cnblogs.com/aoyihuashao/category/1117730.html">hibernate(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_17" href="http://www.cnblogs.com/aoyihuashao/category/1123460.html">soap(1)</a> </li>

</ul>

</div>

<div class="catListPostArchive">
<h3 class="catListTitle">随笔档案<span style="font-size:11px;font-weight:normal">(296)</span></h3>

<ul>

<li><a id="CatList_LinkList_1_Link_0" href="http://www.cnblogs.com/aoyihuashao/archive/2017/11.html">2017年11月 (6)</a> </li>

<li><a id="CatList_LinkList_1_Link_1" href="http://www.cnblogs.com/aoyihuashao/archive/2014/04.html">2014年4月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_2" href="http://www.cnblogs.com/aoyihuashao/archive/2013/10.html">2013年10月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_3" href="http://www.cnblogs.com/aoyihuashao/archive/2013/09.html">2013年9月 (4)</a> </li>

<li><a id="CatList_LinkList_1_Link_4" href="http://www.cnblogs.com/aoyihuashao/archive/2013/07.html">2013年7月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_5" href="http://www.cnblogs.com/aoyihuashao/archive/2013/06.html">2013年6月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_6" href="http://www.cnblogs.com/aoyihuashao/archive/2013/05.html">2013年5月 (6)</a> </li>

<li><a id="CatList_LinkList_1_Link_7" href="http://www.cnblogs.com/aoyihuashao/archive/2013/02.html">2013年2月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_8" href="http://www.cnblogs.com/aoyihuashao/archive/2012/12.html">2012年12月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_9" href="http://www.cnblogs.com/aoyihuashao/archive/2012/11.html">2012年11月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_10" href="http://www.cnblogs.com/aoyihuashao/archive/2012/10.html">2012年10月 (5)</a> </li>

<li><a id="CatList_LinkList_1_Link_11" href="http://www.cnblogs.com/aoyihuashao/archive/2012/09.html">2012年9月 (8)</a> </li>

<li><a id="CatList_LinkList_1_Link_12" href="http://www.cnblogs.com/aoyihuashao/archive/2011/06.html">2011年6月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_13" href="http://www.cnblogs.com/aoyihuashao/archive/2011/04.html">2011年4月 (3)</a> </li>

<li><a id="CatList_LinkList_1_Link_14" href="http://www.cnblogs.com/aoyihuashao/archive/2011/03.html">2011年3月 (6)</a> </li>

<li><a id="CatList_LinkList_1_Link_15" href="http://www.cnblogs.com/aoyihuashao/archive/2010/11.html">2010年11月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_16" href="http://www.cnblogs.com/aoyihuashao/archive/2010/10.html">2010年10月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_17" href="http://www.cnblogs.com/aoyihuashao/archive/2010/09.html">2010年9月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_18" href="http://www.cnblogs.com/aoyihuashao/archive/2010/08.html">2010年8月 (3)</a> </li>

<li><a id="CatList_LinkList_1_Link_19" href="http://www.cnblogs.com/aoyihuashao/archive/2010/07.html">2010年7月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_20" href="http://www.cnblogs.com/aoyihuashao/archive/2010/06.html">2010年6月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_21" href="http://www.cnblogs.com/aoyihuashao/archive/2010/05.html">2010年5月 (12)</a> </li>

<li><a id="CatList_LinkList_1_Link_22" href="http://www.cnblogs.com/aoyihuashao/archive/2010/04.html">2010年4月 (39)</a> </li>

<li><a id="CatList_LinkList_1_Link_23" href="http://www.cnblogs.com/aoyihuashao/archive/2010/03.html">2010年3月 (12)</a> </li>

<li><a id="CatList_LinkList_1_Link_24" href="http://www.cnblogs.com/aoyihuashao/archive/2010/01.html">2010年1月 (30)</a> </li>

<li><a id="CatList_LinkList_1_Link_25" href="http://www.cnblogs.com/aoyihuashao/archive/2009/12.html">2009年12月 (143)</a> </li>

</ul>

</div>

<div class="catListImageCategory">
<h3 class="catListTitle">相册<span style="font-size:11px;font-weight:normal">(12)</span></h3>

<ul>

<li><a id="CatList_LinkList_2_Link_0" href="http://www.cnblogs.com/aoyihuashao/gallery/236431.html" rel="nofollow">技术图片</a> </li>

<li><a id="CatList_LinkList_2_Link_1" href="http://www.cnblogs.com/aoyihuashao/gallery/223549.html" rel="nofollow">普通相册(7)</a> </li>

<li><a id="CatList_LinkList_2_Link_2" href="http://www.cnblogs.com/aoyihuashao/gallery/236430.html" rel="nofollow">奇怪的图片(1)</a> </li>

<li><a id="CatList_LinkList_2_Link_3" href="http://www.cnblogs.com/aoyihuashao/gallery/236432.html" rel="nofollow">提问图片(4)</a> </li>

</ul>

</div>

</div><div id="sidebar_scorerank" class="sidebar-block">
<div class="catListBlogRank">
<h3 class="catListTitle">积分与排名</h3>
<ul>
	<li class="liScore">
		积分 -	59135
	</li>
	<li class="liRank">
		排名 -	6078
	</li>
</ul>
</div>


</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="http://www.cnblogs.com/aoyihuashao/archive/2012/10/08/2715288.html#3648659">1. Re:怎样查外键建在哪个表上</a></li>
        <li class="recent_comment_body">学习了，今天刚好用上</li>
        <li class="recent_comment_author">--葬天VS晓伟</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="http://www.cnblogs.com/aoyihuashao/p/3298950.html">1. SSH自动断开连接的原因(36031)</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/p/3200914.html">2. 在Oracle中查看客户端连接的IP信息 .(11515)</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/archive/2010/01/18/1650865.html">3. Makefile用法，详细到让人吐。(8982)</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/archive/2012/09/14/2684605.html">4. Linux下如何产生coredump（gdb调试用）(8104)</a></li><li><a href="http://www.cnblogs.com/aoyihuashao/archive/2012/10/08/2715288.html">5. 怎样查外键建在哪个表上(6920)</a></li></ul></div>
</div>
</div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2018 雲中鶴
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<script language="javascript" type="text/javascript" src="./Makefile用法，详细到让人吐。 - 雲中鶴 - 博客园_files/3438658.js"></script><a href="https://www.51.la/?comId=3438658" title="51.La 网站流量统计系统" target="_blank"><span style="display:inline-block;background-color:#EF5350;color:#fff;padding:2px 5px;font-family:arial;font-size:12px;font-weight:bold;">51La</span></a>
<noscript>&lt;a href="http://www.51.la/?3438658" target="_blank"&gt;&lt;img alt="&amp;#x6211;&amp;#x8981;&amp;#x5566;&amp;#x514D;&amp;#x8D39;&amp;#x7EDF;&amp;#x8BA1;" src="http://img.users.51.la/3438658.asp" style="border:none" /&gt;&lt;/a&gt;</noscript>
<!--PageEndHtml Block End-->


</body></html>