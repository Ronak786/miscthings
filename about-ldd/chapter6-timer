techniques:
	read from /proc files, use cat can not determine how much data to read
		so use dd bs=20  < /proc/your_file is better
timer:
	include <linux/sched.h>
	HZ in userspace always 100, actually number is not hidden and converted in kernel
		the actually HZ is the timer interrupts in one second, and jiffies will inc by 1

	use jiffies to get jiffies:
		use jiffies / HZ to get seconds
		use time[_after|_before][_eq] to compare two jiffies
		use diff = (long)t2 - (long)t1 to get diff of two jiffies

	or get timespece using
		current_kernel_time()
	or get wall time:
		do_gettimeofday()

	convert from/to struct timespec/timeval to/from jiffies
		timespec_to_jiffies
		timeval_to_jiffies
		jiffies_to_timespec  nanosecond
		jiffies_to_timeval	 microsecond 10^-6
		mktime(...) wall time convert to jiffie

	high_resolution_clock:
		in kernel
		#include <asm/timex.h>
		get_cycles(); if no rdtsc, return 0, otherwise, return rdtsc()
			rdtscll(time)  get clocks

how to wait time:
	long delay: more than one jiffie
		1 use a while loop to check jiffie using timebefore and cpu_relax()
		2 use a while loop to check jiffie using timebefore and schedule() these two both not well, cost too much energy
		3 use wait_event_interruptbile_timeout, just schedule_timeout() (because no one know that wait_queue)
		4 set state to TASK_INTERRUPTBILE and use schedule_timeout, set state is required ,otherwise timer not take effect
	shot delay: 
		busy wait: ndelay udelay mdelay
		msleep[_interruptible]  no busy wait
		ssleep   sleep in second

	
kernel timer: delay execute, may be in interrupt context instead of user process
	#include <linux/timer.h>
	delay execute:
		use in_atomic() in_interrupt()(include<asm/hardirq.h> to judge if we are in environment sleep or schedule NOT permitted,
			if in_interrupt() also current should not be used, and in_atomic() including in_interrupt() and
			spinlock environment;

	NOTE:
		one timerfunc can add itself into timerlist, and added one will run on the same cpu with adding one
			for cache effcient

	usage:
		init_timer
			set function, expire time(final jiffie value),function data
		add_timer  : now start
		del_time   : if you want to cancel, otherwise when timer occurren, it will be removed
		mod_timer :modify expire time of timer
		del_timer_sync: used make sure after return, timer not exucuting,, but will sleep and have lock is dangerous,
						and should make sure timer will not register itself
		timer_pending: if is running

tasklet
