comment:
	/*
	
    */

input/output:
	scanf  %f %g %e are the same!!  will read  "- number . number e  - number"
		%i input: xx  十进制
				011  八进制
				0xa2  十六进制

		浮点：
			float  %e g f
			double %le lf lg (只用于scanf, not used in printf, c99 can but no effect)
			long double %Le Lf Lg  print Le Lf Lg
				
	scanf will skip all blank in input!!  (except %c)

	空白：输入中的空白：这个可选，格式串中一个空白可以对应输入中多个空白或者0个空白，
		但是一定格式串至少一个空白（多个相当于一个），不然对应输入不能有空白
	printf %.2   d  至少两个数字
				s 至少两个字符
				f 至少两个小数

	读写无符号
		%u %o %x
	读写小整数
		%hd hu ho hx
	读写长整数
		%ld lu lo lx
	读写长长整数 c99
		%lld u o x

c99:
	/ 向0取整
	% 和被除数符号相同

	_Bool flag 只能赋值0 或者1
	include <stdbool.h> use bool, 这个实际就是_Bool, 但是更方便, true, false 

	for(int i =0 ; ;)  可以在里面声明使用了
	goto 不能绕过变长数组声明

	检查limits.h 可以查看不同类型值的大小
	新增long long , unsigned long long, 至少64位

	sizeof return size_t, printf  %zu 

	16进制 浮点  0x1.bp3 指数表示的是二的幂


数据类型书写
	123
	012
	0xab
	123U  unsigned
	123L  long
	123UL  
	123LL  long long 
	123ULL unsigned long long

	float double longdouble
	float _Complex, double xxx , longdouble xxx

	常量
		十进制  int long longlong 中最小
		8 16进制 int unsigned , long, u long, longlong, ulonglong中最小
		浮点 默认double
			float 强制 用 F后缀
			long double 强制用 L后缀
			十六进制浮点也是0x开头

	转义：
		'\33' 8进制
		'\xab' 16进制

	转换提升
		如果其中一个浮点, 另一个 float->double->long double
		全是整形，首先提升到int, 然后 int -> unsigned int-> long int- >unsigned long
							如果unsigned int 对 long int, 全部变成 unsigned long

	数组初始化
		指定初始化 int a[] = {1,2,3, [8]=20, [10]=40}; 会推断大小
			注意使用指定位置的后果是下一个是指定之后的位置，和枚举初始化一样
		define size ((int)(sizeof(a) / sizeof(a[0])))

		变长数组
			a[n];  不能静态，不能初始化

		函数变长数组：
			int func(int n, int a[]) or int a[n] or int a[*] or int [] 都可以
			int func(int a[static 3]) 保证至少3个元素

		复合字面量
			int func((int []){1,2,3,4}) 这样传数组 or (int[10]{1,2,3,4,5})


函数：
	getchar putchar   比scanf 更快 , 而且返回int类型

macro:
	#xxx 转换为字符串， #define mad(x)  #x 如果传入空，则产生空字符串
	a##b   转为ab,    #define mac(a,b) a##b 
	注意 # ##两边的宏本身不会扩展，所以 mac(a, mac(b,c))这种会变成amac(b,c), 
		需要定义 #define mac2(a,b) mac(a,b) 然后使用mac2(a, mac2(b,c)) 变成 abc

	可变参数宏
		#define pr(fmt, ...) printf(fmt, __VA_ARGS__) 即可
		#define pr(fmt, ...) printf(fmt, ## __VA_ARGS__) 这个gnu中更好，因为没有可变参数的时候不需要额外的逗号

	__FILE__
	__LINE__
	__func__ 
	__DATE__
	__TIME__

	#if xxx   定义且不为0
	#ifdef  == #if defined 是否定义
#error   错误信息编译
_Pragma("xxxxxx")   代替#pragma 因为是运算符，就可以用在宏定义了，不然宏本身是不能二次执行的

	#include "/root/xxxx.h" 完整路径 "d:\xxx\xxx.h"
		#define MACRO "xx.h"
		#include MACRO

	gcc -DAA=xxx  如果需要定义字符串，需要\"传入引号，如果定义的东西有空格，需要本身shell上外面加引号

多文件
	extern int a[]  数组声明省略大小
