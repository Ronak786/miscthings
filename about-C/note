comment:
	/*
	
    */

input/output:
	scanf  %f %g %e are the same!!  will read  "- number . number e  - number"
		%i input: xx  十进制
				011  八进制
				0xa2  十六进制

		浮点：
			float  %e g f
			double %le lf lg (只用于scanf, not used in printf, c99 can but no effect)
			long double %Le Lf Lg  print Le Lf Lg
				
	scanf will skip all blank in input!!  (except %c)

	空白：输入中的空白：这个可选，格式串中一个空白可以对应输入中多个空白或者0个空白，
		但是一定格式串至少一个空白（多个相当于一个），不然对应输入不能有空白
	printf %.2   d  至少两个数字
				s 至少两个字符
				f 至少两个小数

	读写无符号
		%u %o %x
	读写小整数
		%hd hu ho hx
	读写长整数
		%ld lu lo lx
	读写长长整数 c99
		%lld u o x

c99:
	/ 向0取整
	% 和被除数符号相同

	_Bool flag 只能赋值0 或者1
	include <stdbool.h> use bool, 这个实际就是_Bool, 但是更方便, true, false 

	for(int i =0 ; ;)  可以在里面声明使用了
	goto 不能绕过变长数组声明

	检查limits.h 可以查看不同类型值的大小
	新增long long , unsigned long long, 至少64位

	sizeof return size_t, printf  %zu 

	16进制 浮点  0x1.bp3 指数表示的是二的幂


数据类型书写
	123
	012
	0xab
	123U  unsigned
	123L  long
	123UL  
	123LL  long long 
	123ULL unsigned long long

	float double longdouble
	float _Complex, double xxx , longdouble xxx

	常量
		十进制  int long longlong 中最小
		8 16进制 int unsigned , long, u long, longlong, ulonglong中最小
		浮点 默认double
			float 强制 用 F后缀
			long double 强制用 L后缀
			十六进制浮点也是0x开头

	转义：
		'\33' 8进制
		'\xab' 16进制

	转换提升
		如果其中一个浮点, 另一个 float->double->long double
		全是整形，首先提升到int, 然后 int -> unsigned int-> long int- >unsigned long
							如果unsigned int 对 long int, 全部变成 unsigned long


函数：
	getchar putchar   比scanf 更快 , 而且返回int类型
