SYNCHRONIZATION ISSUES
	lock   scalable clean , must be thought when start design , not after work!!

	ensure unsafe concurrency  and race not happen	, so make critical regions a atomic instruction.
		so we use lock , we have diff types of locks , diff in behavior when lock can not be held
		and the lock code itself is atomic assured	
	user space : pseudo concurrency , multi-pro  , true concurrency
	kernel space: interrupt  softirq tasklet workqueue ,   preemption ,  smp (sleep in cirtical is not allowed)
	
	lock should design beginning ,not afterthought
	we have  smp-safe preempt-safe  interrupt-safe

	the smp and preemption will add lock code to kernel , if not CONFIG_SMP  CONFIG_PREEMPT , those will 
		disappear ,  so choose when needed

	MUCH TAKE CARE OF  global data and share data between interrupt, smp , thread , process , func

	
	DEAD LOCK
		do not lock twice , 
		lock in order
		lock as simple as possible
		make sure procession will finish,so lock will be released absolutely

	lock is needed by more and more scalibility system
	locks begin with a big kernel lock , evolving into nowadays fine-grained lock ,
		but should not be more fine-grained , will add cost to lock overhead
	start simple and grow in complexity only as needed , simplicity is key
	
ATOMIC
	we have atomic integer  and atomic bitwise  implementation , 
	test_bit is atomic implementation , __test_bit() is non atomic

SPIN LOCK
	spin lock will busy waiting , always should disable interrupt , spin_lock_irqsave/irqrestore , 
		(note this lock will disable preempt)
		spin lock can disable interrupt  , bottom half (have some type of funcs)
 
	rw_lock can be acquired(spin lock implement),  
		read can be just acquired in interrupt , but write must disable interrupt
		kernel prefer  read  than write!!
	
		note:  also have rw_semaphore  ,this diffs that can sleep
			and both use uninterruptible  versions' read & write,
			have a downgrade_write to down write into read

	semaphore  can sleep , but have much more overhead ,so short  duration should use spin lock
		 only used in processor context (sleep ) ,can not acquire when having spin lock,
		 , also not  disable preemtption

		we use  down_interruptible  down()  up()  down_trylock sema_init(), to control
			the interrupt means when wait for lock to acquire , can accept signal
			and return fail to get
NOTE:   DECLARE_MUTEX   init_MUTEX used in semapthore
	DEFINE_MUTEX    mutex_init  used in mutex  !!!
	ofter mutex  better than semaphore

	mutex   
		mutex defined for effecient , 

		mutex must be get and release by the same processor , 
			can only be used in processor context ,
			more stricter rules  in Page 196

		
	compeletion :
		DECLARE_COMPLETION()   init_completion  wait_for_completion  complele() 
		when called complete() ,any processor waited on the complete var will be signaled up	

	BKL  big kernel lock
		used only in process  context , 
		can be auto released while sleep ,
		will disable preempt
		use lock_kernel()  unlock_kernel()  kernel_locked()
		
		used when early in kernel 2.0to help smp , now should not used in new code
			mostly used in sync func calls

	seq lock:
		this can be used in interrupt context,
		write_seqlock() write_sequnlock() ,  
		but read in this form
		do {
			read_seqbegin(&xxx)  // the lock
			xxxxx //do some thing simple
			
		} while (read_seqretry(&xxx))  //means the number read now diffs from the number in read_seqbegin
			// so this time's read mixed with write , so must loop reading again
	
		this is lightweight , when have a lot readers , few writers ,data simple , 
			writer never afftec readers' numbers 


	kernel preempt:
		can be disabled enabled by preempt_disable  preempt_enable , also nestable , preempt_enable_nosched()

	barriers: (compiler knows current context's reorder or not , but interrupt happens or not ,don't know)
		mb()  rmb()(read)  wmb()(write) , memory barrier used to set barrier meaning that (load/store/all)
			operations before the barrier will be done before those instructions after the barrier
		smp_rmb  smp_mb smp_wmb  smp_read_barrier_depends() , barrier()(prevent compiler from reordering)
			 these will be memory barriers in smp , and compile barriers in up(uni processor)
		read_barriers_depend() ( this is faster)

		compiler , processor will  reorder two instructions , so in kernel , barrier is important
			eg.  a=1 ; a = 3 ; b =a , now b == 1 or b==3 ? 



TIME MANAGEMENT
	
