SYNCHRONIZATION ISSUES
	lock   scalable clean , must be thought when start design , not after work!!

	ensure unsafe concurrency  and race not happen	, so make critical regions a atomic instruction.
		so we use lock , we have diff types of locks , diff in behavior when lock can not be held
		and the lock code itself is atomic assured	
	user space : pseudo concurrency , multi-pro  , true concurrency
	kernel space: interrupt  softirq tasklet workqueue ,   preemption ,  smp (sleep in cirtical is not allowed)
	
	lock should design beginning ,not afterthought
	we have  smp-safe preempt-safe  interrupt-safe

	the smp and preemption will add lock code to kernel , if not CONFIG_SMP  CONFIG_PREEMPT , those will 
		disappear ,  so choose when needed

	MUCH TAKE CARE OF  global data and share data between interrupt, smp , thread , process , func

	
	DEAD LOCK
		do not lock twice , 
		lock in order
		lock as simple as possible
		make sure procession will finish,so lock will be released absolutely

	lock is needed by more and more scalibility system
	locks begin with a big kernel lock , evolving into nowadays fine-grained lock ,
		but should not be more fine-grained , will add cost to lock overhead
	start simple and grow in complexity only as needed , simplicity is key
	
ATOMIC
	we have atomic integer  and atomic bitwise  implementation , 
	test_bit is atomic implementation , __test_bit() is non atomic

SPIN LOCK
	spin lock will busy waiting , always should disable interrupt , spin_lock_irqsave/irqrestore , 
		(note this lock will disable preempt)
		spin lock can disable interrupt  , bottom half (have some type of funcs)
 
	rw_lock can be acquired(spin lock implement),  
		read can be just acquired in interrupt , but write must disable interrupt
		kernel prefer  read  than write!!
	
		note:  also have rw_semaphore  ,this diffs that can sleep
			and both use uninterruptible  versions' read & write,
			have a downgrade_write to down write into read

	semaphore  can sleep , but have much more overhead ,so short  duration should use spin lock
		 only used in processor context (sleep ) ,can not acquire when having spin lock,
		 , also not  disable preemtption

		we use  down_interruptible  down()  up()  down_trylock sema_init(), to control
			the interrupt means when wait for lock to acquire , can accept signal
			and return fail to get
NOTE:   DECLARE_MUTEX   init_MUTEX used in semapthore
	DEFINE_MUTEX    mutex_init  used in mutex  !!!

	mutex   
		mutex defined for effecient , 
