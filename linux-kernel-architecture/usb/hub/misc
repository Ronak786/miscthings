invoke:
	hub will scan & discovery usb device and call their registered probe func

work thread:
	init work, schedule_work , init_delayed work, schedule_delayed work
	used to do some work in a work thread when the work thread is sheduled to work

hub_init:(main struct: usb_hub)
	open a thread to wait for event to be added into the event list
	insert : hub_event_list will be inserted a event_list of a hub when 
		that hub has event to do, then khub thread waked up to do that 
		hub
	
hub_probe:
	root hub's probe invoked by host controller, other hub's invoked by 
	parent hub.
	in probe ,we judge some error state(class id, endpoint id, interrupt in endpoint only)
		then alloc struct usb_hub and associate it with interface,device
		then call hub_configure=>>

hub_configure:(hub has usual dev intf edp desc ,also has its own hub desc,we now get it)
	allocate some buffer, use usb command to get hub descriptor 
	use desc's charistic to judge removable/power/current state and TT mode;
	at last, prepare a urb in hub->urb for below use, fill in all fields;
	=> in hub power on : power on each port using usb command
	=>activate hub: submit previously filled urb , add self's hub to global
		hub_event_list, then wake it, now hub_init's thread begin work==>

hub_events:
	from list, take out specific added in struct hub
	first get necessary data struct, then get power manger count to prevent
		auto power suspend, if error,reset 
	then start to check every down facing port's condition change(true work)
		we check every port to see if status is changed or not
		we clear port's feature to ack that feature's occurance	
		(if portchange has some attr, then it means that attr is over)

		we start check by getting port's status and change bit;
		if status connect but no child on that port is set in filed,
			then it is a connect change
		if port change in connection bit is set, also connect change.
		if port change from suspend , wake up child
		if port change wierd,(may be elec interfere),report as a change
		if port recover from reset, repower on all ports
		then according to connect_change flag, call hub_port_connect_change

usb_port_connect_change:
	first handle from connect to disconnect:
		disconnect and clear change bit,wait until bounce state to calm down,
			if not connected, just repower and disable port
	then handle come to connect stat:
		according to param set, will try 2 or 4 times(new schem)
			because diff we must get control port's transport size,
			we have new method and old method,both must use two times of tries
		in loop:(we have 8 big functions below)
		usb_alloc_dev:
			alloc a usb_device to represent new inserted dev,
			initialize struct device,attach bus info and control ep info;
			record upstream port info and power suspend info;
			then generate device path in /sys/bus/usb/devices
			interpert: busnum-devpath:conf.intf
				busnum is unique to one hcd, 
				devpath attached by . to relate lots of layers
					if only attached to roothub, no . exists
	 	usb_set_device_state:
			set usb_device->state to  specific  power_on state
			but if this is a roothub, just set to nonattached
		choose_address:
			choose address using bitmap of usb_bus's field dev_bitmap,
			it is a number between 1~127
		hub_port_init:
			get new device's desc and reset it
			first that port's reset,(use a pre decided delay), and
				get speed feature from port status
				then use that speed info to decide predicted max packet
				size of control port
				then use default(new schem)method to get true maxpacket
				size, 
				then set dev port number to device
				then get device descriptor of new device
		after port init:
			check if new dev is a hub, if is ,check  power state,if not
			self powered and power not enough, just return, it is abandoned
			check speed for some device,then start find new device probe in
			usb_new_device
		usb_new_device:
